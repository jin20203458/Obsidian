
**가) char 배열의 초기화시 char 배열의 크기는 초기화 문자열의 크기와 Null을 포함하는 크기로 선언되어야 한다.**

**나) 변수는 사용전 반드시 초기화되어야 한다.**

**다) 값이 초기화되지 않은 변수의 포인터를 함수의 Read-only(const)로 사용해서는 안된다.**

---

**가) char 배열의 초기화시 char 배열의 크기는 초기화 문자열의 크기와 Null을 포함하는 크기로 선언되어야 한다.**

### ❗ 잘못된 예 (위반 사례)

```c
char h1[4] = "Hello";  // ❌ 배열 크기 부족 (5글자 + 널 문자 필요)
char h2[5] = "Hello";  // ❌ 널 문자('\0') 저장 공간 없음
```

- `"Hello"`는 문자 5개 (`'H'`, `'e'`, `'l'`, `'l'`, `'o'`)에 **널 종료 문자** `'\0'`까지 총 6바이트가 필요합니다.
- 배열 크기가 6 미만이면 **널 문자가 저장되지 않아 문자열로 인식되지 않음**
- 이로 인해 `printf`, `strcpy`, `strlen` 등에서 **오류나 오동작 발생 가능**

### ✅ 올바른 예

```c
char h1[6] = "Hello"; // ✅ 5글자 + 널 문자('\0') = 6바이트
```

- 배열 크기를 정확히 맞추거나, 더 크게 잡는 것이 안전합니다.


---

**나) 변수는 사용전 반드시 초기화되어야 한다.**

### ❗ 잘못된 예 (위반 사례)

```c
void foo(void)
{
    int i;
    int j;
    j = i + 2; // ❌ i는 초기화되지 않았음 → 정의되지 않은 동작
}
```

- 지역 변수 `i`는 **초기값이 지정되지 않으면 쓰레기 값**(garbage value)를 가집니다.
- 이 상태로 연산에 사용하면 **예측 불가능한 결과**가 발생할 수 있습니다.
- 컴파일러에 따라 경고가 발생하거나, 심각한 버그로 이어질 수 있습니다.

### ✅ 올바른 예

```c
void foo(void)
{
    int i;
    int j;
    i = 0;       // ✅ i를 명시적으로 초기화
    j = i + 2;
}
```

- 변수 `i`를 사용하기 전에 **명확한 초기값을 지정**함으로써,
- 코드의 동작이 **예측 가능하고 안정적**이 됩니다.


---

**다) 값이 초기화되지 않은 변수의 포인터를 함수의 Read-only(const)로 사용해서는 안된다.**

### ❗ 잘못된 예 (위반 사례)

```c
extern int foo(const int *p);

void foo1(void)
{
    int y;
    int r;
    r = foo(&y); // ❌ y는 초기화되지 않았음
}
```

- `foo()` 함수는 `const int*`를 받아서 **읽기 전용으로 y의 값을 참조**할 가능성이 큽니다.
- 하지만 `y`는 초기화되지 않았기 때문에, `foo()`가 `*p`를 읽으면 **쓰레기 값**(정의되지 않은 값) 을 읽게 됩니다.
- 이는 **정의되지 않은 동작**(undefined behavior)으로 이어질 수 있습니다.

### ✅ 올바른 예

```c
extern int foo(const int *p);

void foo1(void)
{
    int y;
    int r;
    y = 100;       // ✅ y를 명확히 초기화
    r = foo(&y);   // 안전하게 참조 가능
}
```

- `y`를 사용하기 전에 값을 설정함으로써, `foo()`가 `*p`를 읽을 때 **의미 있는 값**을 참조하게 됩니다.


---




