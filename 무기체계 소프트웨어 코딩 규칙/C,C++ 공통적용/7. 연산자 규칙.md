

---

**가) 하나의 Sequence Point 내에서 하나의 Object Value를 두 번 이상 변경하지 않아야 한다.**

### ❌ 잘못된 예 (Sequence Point 내에서 중복 변경)

```c
extern void foo(void) {
    int x = 7;
    x = x++ * x++;  // ❌ 위반: x의 값을 두 번 이상 변경 + 순서 미정
}
```

### 문제점

- `x++ * x++`에서 `x`는 **두 번 변경**되고, 동시에 **읽힘**
- C 표준에서는 **sequence point**(평가 순서가 보장되는 지점) 내에서:

- 결과적으로:
    
    - 컴파일러마다 결과가 다름        
    - 예: Visual Studio는 `51`, CodeWarrior HC12는 `56` 출력
    - **이식성 없음**, **디버깅 어려움**, **예측 불가한 버그 발생**

### ✅ 바른 예 (값을 명확히 분리)

```c
extern void foo(void) {
    int x = 7;
    int y;
    y = x * x;
    y++;
    y++;
}
```

- `x`는 한 번만 읽힘
- `y`는 명확한 순서로 두 번 증가
- **의도한 결과가 항상 동일하게 보장됨**

**시퀀스 포인트**(Sequence Point): C 언어에서 **특정 시점에 이전의 모든 연산이 완료되고, 이후의 모든 연산이 시작되기 전이라는 것을 보장하는 지점**

---

**나) 나누는 값이 변수일 경우 0인지를 반드시 확인하여야 한다.**

### ❌ 잘못된 예 (0으로 나눌 가능성 있음)

```c
void foo(int x, int n) {
    int r;
    r = x / n;  // ❌ n이 0일 경우 → 런타임 오류 (division by zero)
}
```

### 문제점

- `n`이 0일 경우 `x / n`은 **정의되지 않은 동작(undefined behavior)**
    
- 대부분의 시스템에서는:
    
    - **프로그램 크래시**
    - **예외 발생 (예: SIGFPE, divide-by-zero trap)**
    - **보안 취약점의 원인**이 될 수 있음

### ✅ 바른 예 (0 여부 확인 후 나눗셈 수행)

```c
void foo(int x, int n) {
    int r;
    if (n != 0) {
        r = x / n;  // ✅ 안전하게 나눗셈 수행
    }
}
```

- `n`이 0이 아닐 때만 나눗셈 수행
- **런타임 안정성 확보**, **예외 방지**, **이식성 향상**


---

**다) 하나의 Sequence Point내에서 Object의 값을 변경하고 Access 하지 않아야 한다.**

### ❌ 잘못된 예 (Sequence Point 내에서 값 변경 + 접근)

```c
extern void foo(int index)
{
    int r;
    r = (2 * index) + index++;  // ❌ 위반: index를 읽고 동시에 변경
}
```

### 문제점

- `index++`는 **후위 증가 연산자**로, `index`를 사용한 후 값을 증가시킴
- 동시에 `(2 * index)`에서도 `index`를 **읽고 있음**
- 이 표현식은 **하나의 sequence point 내에서 index를 두 번 사용하면서 한 번은 수정**

#### 결과:

- 컴파일러마다 평가 순서가 다르기 때문에 결과도 달라짐
- 예: Visual Studio에서는 `r = 21`, 다른 컴파일러에서는 `r = 24` 등
- **이식성 없음**, **디버깅 어려움**, **예측 불가한 버그 발생**

### ✅ 바른 예 (값을 명확히 분리)

```c
extern void foo(int index)
{
    int r;
    r = (3 * index);  // ✅ index는 한 번만 읽힘
    index++;          // ✅ 이후에 명확히 증가
}
```

- `index`는 한 번만 읽히고, 그 이후에 명확히 증가
- **평가 순서가 명확하고, 정의된 동작만 포함**


---

**라) 음수 값 또는 데이터 사이즈를 초과하는 값을 사용하여 Shift operator를 하지 않는다.**

### ❌ 잘못된 예 (음수 또는 과도한 shift 값 사용)

```c
extern unsigned int uia;

extern void foo(void)
{
    uia = uia << -2;  // ❌ 음수 shift → 정의되지 않은 동작
    uia = uia << 40;  // ❌ 데이터 타입 크기 초과 → 정의되지 않은 동작
}
```

### 문제점

- C 표준(C99 §6.5.7)에 따르면:
    
- `unsigned int`는 보통 32비트이므로:
    
    - 유효한 shift 범위: `0 ~ 31`
    - `-2` → 음수 → **정의되지 않은 동작**
    - `40` → 32비트 초과 → **정의되지 않은 동작**
    
- 결과적으로:
    
    - **컴파일러마다 결과가 다름**
    - **런타임 크래시 또는 잘못된 값 저장**
    - **보안 취약점의 원인**        

### ✅ 바른 예 (정상 범위 내에서 shift)

```c
extern unsigned int uia;

extern void foo(void)
{
    uia = uia >> 2;  // ✅ 유효한 shift 값 (0~31)
}
```

- `>> 2`는 오른쪽으로 2비트 이동
    
- **정의된 동작이며, 이식성 보장**


---

**마) Underlying type이 Unsigned인 데이터에 '-'를 사용하여 결과를 assign하지 말아야 한다.**

### ❌ 잘못된 예 (unsigned 타입에 음수 연산 적용)

```c
void foo(unsigned char i)
{
    long j;
    j = -i;  // ❌ unsigned 타입에 음수 연산 → 의도와 다른 결과
}
```

### 문제점

- `i`는 `unsigned char` → 항상 0 이상

- `-i`는 **산술적으로 음수처럼 보이지만**, 실제로는:
    
    - `i`가 먼저 `int`로 **정수 승격(integer promotion)**됨
    - 그 후 `-` 연산이 적용되지만, **원래의 의미와 다르게 해석될 수 있음**
        
- 예를 들어 `i = 1`이면 `-i = -1`이지만,
    
    - `i = 255`이면 `-i = -255`가 아니라 **큰 양수로 wrap-around**될 수 있음
        
- 결과적으로:
    
    - **이식성 없음**
    - **의도하지 않은 값 저장**
    - **디버깅 어려움**

### ✅ 바른 예 (signed 타입 사용)

```c
void foo(signed char i)
{
    long j;
    j = -i;  // ✅ 부호 있는 타입에 음수 연산 → 의미 보존
}
```

- `signed char`는 음수 표현 가능
- `-i`는 정확하게 **산술적 음수 연산**으로 해석됨
- **의도한 결과가 정확히 나옴**


---