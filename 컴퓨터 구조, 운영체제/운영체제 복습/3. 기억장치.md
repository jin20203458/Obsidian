주요사항 : 프로그램이 실행되려면 주기억장치(메모리)에 로드되어야한다.

기억장치의 이중성

기억장치는 도마, 프로세스는 식재료와 같다. 기억장치는 최대한 공정하게 자원을 관리하려 하지만 프로세스는 실행이 목표이기에 최대한 많은 자원을 바란다.

1. **컴파일 타임 바인딩 (Compile-Time Binding)**

컴파일 타임 바인딩에서는 프로그램이 컴파일될 때 메모리의 물리 주소가 결정
유연성이 매우낮고 프로그램을 다른 메모리 위치에서 실행하려면 컴파일을 다시해야됨

2. **로드 타임 바인딩 (Load-Time Binding)**
프로그램을 메모리에 로드하는 시점에 물리 주소가 결정
메모리 위치를 옮기려면 재로드 과정을 거쳐야함으로 많은 오버해드가 발생됨

3. **런타임 바인딩 (Runtime Binding)**

프로그램이 **실행되는 동안** 물리 주소가 결정되고, 실행 중에도 주소가 동적으로 변환

이 방식에서는 프로그램이 **논리 주소**만 가지고 실행되며, 실행 중에 논리 주소가 **MMU**(Memory Management Unit) 등의 하드웨어를 통해 물리 주소로 변환(단 주소변환의 오버해드는 발생)

### 요약 비교

|**바인딩 방식**|**결정 시점**|**유연성**|**주소 변환 방식**|**장점**|**단점**|
|---|---|---|---|---|---|
|**컴파일 타임 바인딩**|컴파일 시점|낮음|컴파일 시에 물리 주소로 직접 변환|단순한 구조, 실행 시 오버헤드 없음|유연성 부족, 메모리 위치 변경 불가|
|**로드 타임 바인딩**|프로그램 로드 시점|중간|실행 전에 상대 주소를 물리 주소로 변환|다른 메모리 위치에서 실행 가능|실행 중에 주소 변경 불가|
|**런타임 바인딩**|실행 시점(실행 중)|높음|실행 중 MMU로 논리 주소를 물리 주소로 변환|높은 유연성, 가상 메모리 사용 가능, 메모리 효율성 증가|주소 변환 오버헤드(하드웨어로 최소화 가능)|

단일 사용자 연속 기억장치 할당

![[Pasted image 20241001233503.png]]
메모리의 끝부분 부터 할당, 시스템 보호는 커널단에 경계레지스터를 사용하여 사용자 프로그램이 커널을 침범하지 않도록함

오버레이 기법:  프로그램의 크기가 물리적 메모리보다 클 때, 메모리의 제한을 극복하기 위해 사용되는 기법
프로그램을 분할하여 필요한 오버레이만 적재하고 필요하지 않은 오버레이는 메모리에서 제거(필요할때 다시 적재)


다중프로그래밍 시스템
- 분할크기 : 고정, 가변
- 분할된 메모리 영역에 프로세를 할당하는 방법 : 연속 할당, 불연속 할당


용어:
- 내부 단편화: 고정된 크기의 메모리 블록이 할당될 때, 사용되지 않고 남은 메모리 공간이 생기는 현상.
- 외부 단편화: 가변 크기의 메모리 블록이 할당되고 해제될 때, 작은 자유 공간들이 분산되어 실제로 사용할 수 없는 상태가 되는 현상.
 - 연속 할당 (Contiguous Allocation) : 프로세스가 연속된 메모리 블록에 할당되는 방식
 - 불연속 할당 (Non-contiguous Allocation) : 프로세스가 여러 개의 불연속된 메모리 블록에 나뉘어 할당되는 방식입니다. 즉, 프로세스의 각 부분이 메모리의 여러 위치에 분산되어 적재

연속할당

1. 고정분할 : 분할크기를 고정 (내부, 외부 단편화 발생)

절대 번역및 로딩 : 프로그램의 메모리 위치가 고정
재배치 가능 번역및 로딩 : 프로그램의 자리이동이 가능(실행시간)

2. 가변분할
공백 합병 : 인접한 빈 공간이 생기면 합친다.
메모리 집약: 모든 빈 공간들을 주기적으로 합친다.


