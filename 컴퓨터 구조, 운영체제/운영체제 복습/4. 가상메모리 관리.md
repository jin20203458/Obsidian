가상 메모리 : 실행하고자 하는 프로그램을 일부만 적재하여 메모리보다 큰 프로세스를 실행할수 있게 하는 기술
(페이징, 세그먼트등,,)

가상 주소 공간 : 프로세스가 사용하는 논리적인 주소(자신만의 가상의 주소)
물리 주소         : 실제 메모리의 주소


인위적 연속성 : 물리적으로 연속되지 않은 메모리 공간을 마치 연속적인 메모리 공간처럼 사용하는 기법

- 메모리 관리 기법에서 프로그램이 물리적 메모리의 여러 곳에 흩어져서 저장될 수 있지만, 프로세스가 이를 인식하지 못하게 하여 연속된 메모리 공간처럼 보이도록 만듭니다.
- 가상 주소를 이용해 물리적 메모리의 위치를 추상화하고, 주소 변환을 통해 실제 물리 주소와 논리 주소 간의 매핑을 관리합니다. 이를 통해 프로그램은 연속된 메모리 공간을 사용하는 것처럼 동작합니다.
- 인위적 연속성을 구현하기위해 가상 메모리에서의 가성 주소를 물리주소로 변환하기 위한 사상 정보를 저장하는 테이블을 가진다. (페이지 테이블, 세그먼트 테이블 등...).


블록 사상 : 캐시 메모리에서 주기억장치(메인 메모리)의 데이터를 캐시 메모리로 어떻게 매핑할지 결정하는 방법, 주로 캐시 메모리 관리 기법에서 사용
(직접 사상, 연관 사상, 직접-연관 사상등 다양한 방식이 존재)

- 모든 블럭이 같은 크기 = 페이징
- 모든 블럭이 프로세스의 크기 = 세그먼테이션



 페이징 : 프로세스의  주소를 일정한 크기로 자름(스왑도 가능), 불연속적 할당
 
 - 페이지:
    - 가상 메모리를 **고정된 크기**로 나눈 작은 블록. 각 페이지는 일정한 크기를 가지며, 프로세스의 메모리 공간을 나누어 관리하는 단위.
- 프레임:
    - 물리 메모리를 페이지와 동일한 크기로 나눈 블록. **페이지**는 **프레임**에 적재되며, 페이지는 프레임에 매핑.
    - 가상 메모리의 각 페이지가 물리적 메모리의 어디에 저장될지 결정되는 공간이 프레임
- **페이지 테이블(Page Table)**:
    - **가상 주소의 페이지 번호**와 **물리 메모리의 프레임 번호**를 매핑하는 테이블. 페이지 테이블은 각 프로세스마다 존재하며, 운영 체제가 이를 관리.
    - 프로세스가 메모리에 접근할 때, 가상 주소를 실제 물리 주소로 변환하는 역할을 합니다.



**주소 변환 (Address Translation)**:

- 가상 메모리의 주소는 **페이지 번호(Page Number)**와 **페이지 오프셋(Page Offset)**으로 구성됩니다.
- **페이지 번호**는 페이지 테이블을 통해 물리적 메모리의 프레임 번호로 변환되며, 변환된 프레임 번호에 **페이지 오프셋**을 더해 물리적 주소를 계산합니다.

 1. 직접사상 (Direct Mapping)

- **정의**: 가상 페이지 번호를 특정 물리적 페이지 프레임에 직접 대응시키는 방식.
- **작동 방식**: 가상 페이지 번호를 물리적 페이지 프레임으로 나누는 방식으로 매핑이 이루어지며, 이를 통해 페이지가 어느 물리적 프레임에 들어가야 할지가 바로 결정.
- **장점**: 구현이 간단하고 빠릅니다.
- **단점**: 가상 주소 공간의 크기에 비해 물리적 메모리 크기가 작을 경우, 충돌이 자주 발생할 수 있다. 즉, 동일한 물리적 페이지 프레임에 여러 가상 페이지가 매핑되려는 경우가 많아질 수 있습니다.

 2. 연관사상 (Associative Mapping)

- **정의**: 가상 페이지가 어떤 물리적 페이지 프레임에 위치할지 제한을 두지 않고, 페이지 테이블에 있는 모든 페이지 프레임 중 하나에 자유롭게 매핑할 수 있게 하는 방식.
- **작동 방식**: 연관 메모리(Associative Memory)라는 특별한 하드웨어를 사용하여, 어떤 가상 페이지가 메모리에 있을 경우, 이를 빠르게 탐색하고 물리적 주소를 찾고. 모든 페이지 프레임에 대해 일종의 검색을 수행하여 매핑.
- **장점**: 충돌이 거의 발생하지 않아 매우 유연.
- **단점**: 하드웨어 구현이 복잡하고 비용이 많이 들며, 검색 시간이 많이 소요될 수 있습니다.

3. 직접-연관사상 (Set-Associative Mapping)

- **정의**: 직접사상과 연관사상의 혼합형 방식으로, 가상 페이지 번호가 매핑될 수 있는 물리적 페이지 프레임의 집합을 두고, 그 중 하나로 매핑하는 방식입니다.
- **작동 방식**: 가상 페이지 번호가 여러 물리적 페이지 프레임 중에서 선택적으로 매핑될 수 있습니다. 예를 들어, 2-way 연관사상에서는 한 페이지가 두 개의 페이지 프레임 중 하나에 매핑됩니다. 연관 사상보다 유연성을 제공하면서도 직접 사상보다 충돌을 줄일 수 있는 타협안입니다.
- **장점**: 직접사상보다 충돌을 줄일 수 있으며, 연관사상보다 구현이 간단합니다.
- **단점**: 여전히 충돌 가능성이 존재하며, 하드웨어 복잡도는 직접사상보다는 높습니다.


 **공유 페이지 (Shared Pages)**

- 정의: 여러 프로세스가 동일한 데이터를 사용하는 경우, 동일한 페이지를 여러 프로세스가 공유하여 메모리 공간을 절약하는 방식.
- 예시:
    - **라이브러리 코드 공유**: 다중 사용자 환경에서는 여러 프로세스가 동일한 **공유 라이브러리** (C 라이브러리, GUI 라이브러리)를 사용할 수 있다. 이러한 경우 동일한 라이브러리 코드가 여러 번 메모리에 로드되는 것을 방지하고, 하나의 물리적 페이지를 여러 프로세스가 참조하게 함으로써 메모리 절약이 가능.
    - **읽기 전용 데이터 공유**: **읽기 전용(read-only)** 페이지(예: 실행 코드 또는 상수 데이터)는 여러 프로세스가 동시에 읽기만 하기 때문에 메모리 페이지를 안전하게 공유할 수 있습니다.
- **장점**: 메모리 사용을 최적화하고, 중복된 데이터를 메모리에 여러 번 로드하는 것을 방지합니다.
- **단점**: 쓰기 가능한 데이터를 공유하려면 추가적인 보호 기법이 필요합니다.

|**비교 항목**|**페이지 크기가 클 때**|**페이지 크기가 작을 때**|
|---|---|---|
|**페이지 테이블 크기**|- 페이지 수가 적으므로 페이지 테이블 크기가 작아짐.|- 페이지 수가 많아지므로 페이지 테이블 크기가 커짐.|
|**내부 단편화**|- 페이지 크기보다 작은 데이터는 낭비되어 내부 단편화가 커짐.  <br>- 단편화로 인해 메모리 비효율 발생 가능.|- 페이지 크기가 작아서 내부 단편화가 적어짐.  <br>- 메모리 공간을 더 효율적으로 사용.|
|**입출력(I/O)**|- 한 번에 더 많은 데이터를 읽고 쓰므로 입출력 효율이 증가함.  <br>- I/O 작업의 빈도가 감소.|- 작은 크기의 페이지는 한 번에 처리하는 데이터 양이 적으므로 I/O 효율이 낮아짐.  <br>- I/O 작업의 빈도가 증가.|

페이지 인출기법

|**특징**|**요구 페이징 (Demand Paging)**|**예상 페이징 (Pre-Paging)**|
|---|---|---|
|**페이지 로드 시점**|필요한 페이지가 요청될 때 로드|앞으로 필요할 것으로 예상되는 페이지를 미리 로드|
|**페이지 폴트 발생 빈도**|페이지 폴트가 자주 발생할 수 있음|페이지 폴트 발생 빈도가 줄어듦|
|**메모리 사용 효율성**|메모리를 효율적으로 사용|예측 실패 시 메모리 낭비 가능|
|**초기 로드 시간**|빠름|예측 페이지 수에 따라 느릴 수 있음|

페이지 양도 : 가상 메모리 관리에서 물리적 메모리가 가득 찼을 때, 기존의 페이지 중 하나를 선택하여 디스크로 내보내고 새로운 페이지를 메모리에 로드하는 과정 보통 os나 컴파일 단위에서 실행 ( 사용자 단계에서는 권장하지 않음 )



세그멘테이션 : 프로세스의  주소를 프로세스의 크기대로 자름, 불연속적 할당

- **세그먼트 (Segment)**:
    - 세그먼트는 프로그램의 논리적 단위를 나타내며, 크기가 가변적. 예를 들어, 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트 등이 있습니다.
- **세그먼트 테이블 (Segment Table)**:
    - 각 프로세스는 세그먼트에 대한 정보를 저장하는 세그먼트 테이블을 가짐. 세그먼트 테이블에는 각 세그먼트의 시작 주소와 크기(길이)가 포함.
    - 세그먼트 테이블의 각 항목은 다음과 같은 정보를 포함:
        - **세그먼트 번호**: 각 세그먼트를 식별하는 번호.
        - **베이스 주소**: 해당 세그먼트가 물리적 메모리에서 시작하는 주소.
        - **한계(크기)**: 세그먼트의 크기를 나타내며, 이를 통해 접근 가능한 메모리 범위를 정의합니다.

세그먼트 사상 테이블 :

세그멘테이션에서 프로세스의 세그먼트 정보를 관리하는 중요한 데이터 구조. 세그먼트 번호, 베이스 주소, 한계, 접근 권한 등의 정보를 포함하여, 논리적 주소를 물리적 주소로 변환하는 데 필수적인 역할을 함

접근 제어 권한 r 읽기, w쓰기, x실행, a추가

세그먼트의 공유 또한 페이지 공유와 마찬가지로 프로세스의 공유가능한 세그먼트를 공유할수 있다. (읽기전용)


세그먼트- 페이지 혼용기법
세그먼트의 크기가 너무 클 경우 관리가 힘든 단점을 보완하기 위해 세그먼트를 고정 크기의 페이지로 나누어 관리하는 기법으로, 세그멘테이션의 유연성과 페이지 기법의 효율성을 결합하여 메모리 단편화를 줄이는 방법

- **세그먼트(Segment)**:
    - 프로그램을 의미 있는 단위로 나누는 방법으로, 각 세그먼트는 코드, 데이터, 스택 등 프로그램의 논리적 구조를 반영합니다. 세그먼트는 가변 크기를 가질 수 있습니다.
- **페이지(Page)**:
    - 각 세그먼트를 고정 크기의 페이지로 나누어 관리합니다. 페이지 크기는 보통 운영체제에 의해 설정되며, 페이지는 일반적으로 메모리의 프레임에 맵핑됩니다.
- **세그먼트 테이블(Segment Table)**:
    - 각 프로세스는 자신의 세그먼트 정보를 저장하는 세그먼트 테이블을 가지고 있습니다. 이 테이블은 각 세그먼트의 베이스 주소(첫 번째 페이지의 시작 주소)와 세그먼트의 크기(한계)를 포함합니다.
- **페이지 테이블(Page Table)**:
    - 각 세그먼트는 또 다른 페이지 테이블을 가지고 있으며, 이 페이지 테이블은 각 페이지의 물리적 메모리 프레임 위치를 관리합니다. 각 페이지 테이블은 해당 세그먼트의 페이지에 대한 매핑 정보를 포함합니다.

매핑과정

- **논리적 주소의 구성**:
    - 논리적 주소는 세그먼트 번호, 페이지 번호, 페이지 내 오프셋으로 구성. 예를 들어, 논리적 주소 (세그먼트 번호 s, 페이지 번호 p, 페이지 내 오프셋 d) = (2, 1, 15)일 경우:
        - 2는 세그먼트 번호,
        - 1은 페이지 번호,
        - 15는 페이지 내의 오프셋.
- **세그먼트 테이블 참조**:
    - 운영체제는 세그먼트 번호를 사용하여 세그먼트 테이블을 참조하고, 해당 세그먼트의 베이스 주소와 페이지 테이블의 위치를 찾습니다.
- **페이지 테이블 참조**:
    - 페이지 번호를 사용하여 해당 세그먼트의 페이지 테이블을 참조합니다. 페이지 테이블에서 페이지의 프레임 번호를 찾습니다.
- **물리적 주소 계산**:
    - 물리적 주소는 다음과 같이 계산됩니다:
    물리적 주소=프레임 번호×페이지 크기+페이지 내 오프셋



페이지 교체 알고리즘

페이징 기법으로 페이지를 적재하다 보면 메모리가 가득찬다
그럼 어떤 페이지를 아웃 시켜야할까?

- 페이지 교체가 적은 알고리즘(보조기억 장치에 다수접근 x)

**FIFO** 
- 메모리에 가장 먼저 올라온 페이지부터 내쫓음
**FIFO 모순(FIFO anomaly)**, 또는 **Belady's Anomaly**는 페이지 교체 알고리즘 중 하나인 **FIFO(First In, First Out)**에서 발생하는 **비정상적인 현상**을 가리킵니다. 이 현상은 페이지 프레임의 수가 늘어나도 페이지 폴트(page fault)의 수가 줄어들지 않고, 오히려 **증가하는 역설적인 상황**을 설명합니다. 보통 페이지 교체 알고리즘은 메모리 프레임이 증가하면 페이지 폴트가 줄어드는 것이 일반적입니다. 그러나 FIFO 알고리즘에서는 메모리 프레임이 늘어나도 페이지 폴트가 증가할 수 있는 경우가 발생합니다.

**FIFO 보완책(2차 기회 페이지 교체 알고리즘)**
- 참조 비트에 따라 기회를 판결
- CPU가 참조한적이 있으면 기회를 준다.(다시 참조비트는 0)

**최적 페이지 교체 알고리즘**
- 앞으로 오랫동안 사용되지 않을 페이지를 예측
- 구현의 어려움으로 성능 평가용으로 많이 사용

**LRU 알조리즘**
- 지금까지 가장 오래 사용되지 않은 페이지 교체
- **LRU 스택 형식**: 사용된 페이지들을 스택에 저장하고, 가장 최근에 사용된 페이지를 스택의 맨 위에 두는 방식으로, 페이지가 사용될 때마다 해당 페이지를 스택에서 제거하고 맨 위로 이동시킵니다.
- **LRU 타임스탬프 형식**: 각 페이지에 마지막으로 접근된 시간을 기록하여, 페이지 교체 시 가장 오래전에 사용된 페이지(가장 낮은 타임스탬프)를 교체하는 방식입니다.

- **LFU(Least Frequently Used)**: 사용 횟수가 가장 적은 페이지를 교체하는 페이지 교체 알고리즘입니다.
- **MFU(Most Frequently Used)**: 사용 횟수가 가장 많은 페이지를 교체하는 알고리즘으로, 최근 자주 사용된 페이지는 다시 사용되지 않을 것이라는 가정에 기반합니다.
- **NVR(Not Recently Used)**: 최근에 사용되지 않은 페이지를 교체하는 방식으로, 사용 빈도보다는 최근 사용 여부에 따라 교체 페이지를 결정합니다.

- **스레싱(Thrashing)**: 페이지 폴트가 너무 자주 발생하여, CPU가 대부분의 시간을 페이지 교체 작업에 소모하는 비효율적인 상태입니다.
    
- **구역성(Locality)**:
    
    - **시간 구역성(Temporal Locality)**: 최근에 사용된 데이터가 곧 다시 사용될 가능성이 높음.
    - **공간 구역성(Spatial Locality)**: 한 번 참조된 데이터의 근처 데이터가 곧 참조될 가능성이 높음.
- **작업세트 이론(Working Set Theory)**: 프로그램이 일정 시간 동안 자주 참조하는 페이지들의 집합을 **작업 세트**라 하며, 이 집합을 메모리에 유지함으로써 페이지 폴트를 최소화하려는 이론입니다.
    
- **부재율(Page Fault Rate)**: 실행 중인 프로그램이 메모리에 없는 페이지를 참조할 때 발생하는 **페이지 폴트** 비율을 의미합니다.