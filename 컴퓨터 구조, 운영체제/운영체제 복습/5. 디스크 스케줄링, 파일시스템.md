
### 하드디스크

- 자기적 방식으로 데이터 저장
- 실질적 저장 원판(플레터), 이를 돌리는 구성요소(스핀들)
- 플레터를 대상으로 읽고 쓰는 구성요소(헤드), 이를 이동시키는 부품 (디스크암)
- RPM (분당회전수)

- 트랙(동그란 원형 경로)과 섹터(트렉을 작은 구역으로 나눈것)로 나누어서 데이터 저장
- 같은 트랙이 위치한 논리적 단위 = 실린더

하드 디스크 드라이브(HDD)에서 데이터를 읽고 쓰기 위한 주요 시간 지표로는 **탐색 시간**, **회전 지연 시간**, 그리고 **전송 시간**이 있다.

탐색시간 : 접근하려는 데이터가 저장된 트렉까지 헤드를 이동하는시간
회전 지연시간 : 헤드가 있는 곳으로 플레터를 회전하는 시간
전송시간 : 하드디스크와 컴퓨터간 데이터를 전송하는 시간

탐색 시간 >> 회전지연 시간 >>>> 전송시간


1. **FCFS(First-Come, First-Served)**

**설명**: 요청이 **들어온 순서대로** 처리하는 방식.
**단점**: 요청이 순서대로 처리되다 보니, 헤드가 디스크 전체를 **불필요하게 많이 이동**하게 될 수 있어 성능이 떨어짐

 2. **SSTF(Shortest Seek Time First)**

- **설명**: 헤드에서 **가장 가까운 트랙**의 요청을 먼저 처리하는 방식.
- **단점**: 가까운 요청만 계속 처리되면서, 먼 트랙의 요청이 **기아 상태**(오랫동안 처리되지 않음)가 될 수 있슴.

 3. **SCAN(엘리베이터 알고리즘)**

- **설명**: 디스크 헤드가 **한 방향으로 이동**하면서 요청을 처리하고, 끝에 도달하면 **반대 방향으로 이동**하며 다시 요청을 처리하는 방식. 엘리베이터가 위아래로 움직이는 것과 비슷해서 **엘리베이터 알고리즘**이라고도 함.
- **장점**: 먼 요청이 기아 상태에 빠지지 않고, **효율적으로** 요청을 처리.
- **단점**: 양방향 이동이 비효율적.

 4. **C-SCAN(Circular SCAN)**

- **설명**: SCAN 알고리즘의 변형으로, 디스크 헤드가 **한 방향으로만 이동**하여 요청을 처리한 후 끝에 도달하면 **가장 바깥쪽**에서 다시 시작.
- **장점**: 모든 요청에 대한 **대기 시간이 일정**해지는 효과가 있슴.
- **단점**: 헤드가 되돌아올 때 추가 이동이 필요해 일부 비효율.

 5. **LOOK**

- **설명**: SCAN과 비슷하지만, 끝까지 가지 않고 **마지막 요청이 있는 지점까지만 이동**한 후 방향을 바꿈.
- **장점**: SCAN보다 불필요한 이동을 줄여 효율성을 향상.

 6. **C-LOOK(Circular LOOK)**

- **설명**: LOOK 알고리즘의 변형으로, 헤드가 한쪽 끝까지 가지 않고 **마지막 요청이 있는 지점까지만** 처리한 후 다시 **가장 안쪽 요청부터 처리**하는 방식.

7. N STEP SCAN
- 설명: SCAN 요청 처리 방식을 따르되, 처리과정 중 도착한 요청은 별도 보관하여 반대방향으로 전환후 처리

8. 에센바흐기법
- 설명 : 요청처리 방식은 기본적으로 C-SCAN을 따르되 헤더가 처음 트렉에서 서비스를 시작할 때, 이미 도착한 요청과 새로 들어온 요청을 재배열하여 처리

9. SLTF
- 설명 : 회전 지연시간 최적화 기법

큐가 하나라면 FCFS가 좋다. 
디렉터리는 디스크의 끝보다 중간에 있는것이 상대적 탐색시간을 최소화 할수 있다.

RAID(Redundant Array of Independent Disks)는 여러 개의 하드 디스크를 하나의 논리적인 장치로 묶어 데이터의 안정성과 성능을 향상시키는 기술

 1. **RAID 0 (Striping)**

- **개요**: RAID 0은 **데이터를 여러 디스크에 분산 저장**하여 성능을 향상시키는 방식입니다. 데이터가 스트라이핑되어 여러 디스크에 나뉘어 저장되므로 **읽기 및 쓰기 속도가 빨라집**니다.
- **장점**: 성능 향상(읽기, 쓰기 속도 모두), 전체 용량 활용 가능.
- **단점**: **데이터 보호 기능이 없습**니다. 디스크 중 하나라도 고장 나면 모든 데이터가 손실됩니다.

 2. **RAID 1 (Mirroring)**

- **개요**: RAID 1은 **데이터를 동일하게 두 개의 디스크에 복제**(미러링)하여 저장하는 방식입니다. 하나의 디스크가 고장 나더라도 다른 디스크에서 데이터를 복원할 수 있습니다.
- **장점**: **데이터 보호가 우수**합니다. 한 디스크가 고장 나도 데이터가 손실되지 않습니다.
- **단점**: 성능 향상은 RAID 0에 비해 크지 않고, 저장 공간의 절반만 사용할 수 있습니다. 두 개의 디스크가 같은 데이터를 저장하기 때문입니다.

 3. **RAID 10 (RAID 1+0 또는 RAID 0+1)**

- **개요**: RAID 10은 RAID 1과 RAID 0의 결합으로, **데이터를 스트라이핑하면서도 미러링**하는 방식입니다. 여러 디스크에 데이터를 분산하여 저장하면서도 각각의 데이터를 미러링하여 안전하게 보관합니다. **최소 4개의 디스크가 필요**합니다.
- **장점**: RAID 0의 성능 향상과 RAID 1의 데이터 보호 기능을 결합한 방식입니다. 고속 성능과 높은 안정성을 모두 갖춘 구성이 가능합니다.
- **단점**: 최소 4개의 디스크가 필요하며, 저장 용량이 절반으로 감소합니다.


### 파일시스템

파일 : 저장장치에 저장되는 실제 데이터
파일 테이블 : 파일 시스템에서 파일에 대한 메타데이터와 위치 정보를 저장하는 데이터 구조

#### **파일 테이블이 포함하는 정보**

- **파일 이름**: 파일의 이름과 경로 정보.
- **파일 크기**: 파일의 총 크기(바이트 단위).
- **파일 위치**: 파일이 디스크 상에서 실제로 저장된 위치(섹터나 클러스터 등).
- **파일 속성**: 파일의 읽기, 쓰기, 실행 권한 등.
- **생성 및 수정 시간**: 파일이 생성된 시간과 마지막으로 수정된 시간.
- **연결 정보**: 파일이 여러 섹터에 걸쳐 있을 때 각 섹터나 클러스터 간의 연결 정보.



**파일 구성**
파일은 레코드들의 집합으로 구성되며, 레코드는 다시 여러 필드로 구성됩니다. 필드가 각 데이터를 저장하고, 레코드는 그 데이터를 묶어 하나의 엔티티를 표현하며, 레코드 키는 이 레코드를 고유하게 식별하는 역할을 합니다.

- **필드**는 데이터를 저장하는 가장 작은 단위입니다.
- **레코드**는 여러 필드를 하나로 묶은 데이터 단위입니다.
- **레코드 키**는 파일 내에서 특정 레코드를 고유하게 식별할 수 있는 필드입니다.

### 논리적 레코드 vs. 물리적 레코드

- **논리적 레코드(Logical Record)**:
    - 사용자가 데이터 파일에서 인식하는 데이터 단위입니다. 예를 들어, 한 명의 고객 정보(이름, 주소, 전화번호 등)를 하나의 논리적 레코드로 볼 수 있습니다.
    - 논리적 레코드는 사용자가 필요로 하는 개별 데이터 단위로, 데이터베이스나 파일 시스템에서 각 데이터를 조직화한 형태입니다.
- **물리적 레코드(Physical Record)**:
    - 실제로 디스크에 저장되는 데이터 단위입니다. 디스크는 데이터를 블록(block)이라는 큰 단위로 관리하기 때문에, 하나의 물리적 레코드는 여러 개의 논리적 레코드를 포함할 수 있습니다.
    - 물리적 레코드는 파일 시스템이 디스크에서 데이터를 처리하는 단위로, 보통 여러 개의 논리적 레코드를 포함하는 블록 단위로 구성됩니다.

**블로킹**은 이러한 **논리적 레코드**를 **물리적 레코드**로 변환하는 과정입니다. 논리적 레코드를 여러 개 묶어서 하나의 물리적 레코드로 변환하는 것이 블로킹의 핵심입니다. 즉, 여러 개의 논리적 레코드를 한 번에 처리하여 물리적 레코드(블록)로 저장하는 것입니다.

고정길이 레코드 : 모든 레코드가 동일한 크기를 지님
가변길이 레코드 : 각 레코드가 서로 다른 크기를 지님 (최대 크기는 블록의 크기)

파일 시스템의 기능
- 파일 구성
- 파일 관리
- 보조 메모리 관리
- 파일 무결성 보장(권한)
- 파일 접근 방법 제공
- 장치 독립성 유지
- 파일 백업과 복구
- 정보보호
- 정보제공
- UFI 제공(고유 파일 식별자(Unique File Identifier))

##### 파일에 접근하는 논리적 방식

 1. **순차 파일 (Sequential File)**
- 일괄처리에서 많이 사용, 연속 저장
- **순차 파일**은 데이터가 **일정한 순서**대로 저장되고, 그 순서대로만 접근할 수 있는 파일입니다. 즉, 데이터를 저장하거나 읽을 때 항상 **처음부터 끝까지** 순차적으로 처리해야 합니다.


2. 직접 파일 (Direct File)

- 대화형 프로그램에서 많이 사용, 파일내 특정 위치에 저장 ( 해시함수나, 주소 계산 으로 결정 )
- 직접 파일(또는 랜덤 파일이라고도 함)은 데이터를 직접 접근할 수 있는 파일입니다. 데이터가 파일 내 특정 위치에 저장되며, 파일 내의 임의의 위치에 있는 데이터를 바로 읽거나 쓸 수 있습니다.

3. 색인된 순차 파일 (Indexed Sequential File)

색인된 순차 파일은 순차 파일의 순차적 접근 방식과 직접 파일의 랜덤 접근 방식을 혼합한 구조입니다. 데이터는 순차적으로 저장되지만, 빠른 접근을 위해 **색인(Index)**을 추가로 제공합니다.

기본적으로 순차적으로 저장되지만, 추가적으로 **색인 테이블(키 벨류 구조)**이 있어서 특정 데이터를 빠르게 찾을 수 있습니다.


|특징|**순차 파일 (Sequential File)**|**직접 파일 (Direct File)**|**색인된 순차 파일 (Indexed Sequential File)**|
|---|---|---|---|
|**데이터 저장 방식**|데이터가 순차적으로 저장됨|해시 또는 주소 계산을 통한 직접 저장|순차 저장 + 색인 테이블을 통해 관리|
|**데이터 접근 방식**|순차적 접근만 가능|임의 위치로 직접 접근 가능|순차 접근 + 색인을 통한 랜덤 접근 가능|
|**랜덤 접근 성능**|느림|매우 빠름|빠름|
|**데이터 수정 및 삭제**|복잡함|효율적|색인 업데이트가 필요|
|**사용 예시**|로그 파일, 트랜잭션 기록|데이터베이스, 검색 시스템|대규모 데이터베이스, 파일 시스템|

#### 파일이 디스크 상에서 저장및 할당되는 방식

1. 연속 할당(Contiguous Allocation)
연속 할당은 파일이 디스크에서 연속된 블록에 저장되는 방식입니다. 즉, 파일에 필요한 모든 데이터가 디스크의 연속된 공간에 저장됩니다.

2. 불연속 할당(Non-contiguous Allocation)
불연속 할당은 파일이 디스크 상에서 연속적이지 않은 여러 블록에 나누어 저장되는 방식입니다. 즉, 파일의 데이터가 여러 군데 분산되어 저장될 수 있습니다.(리스트, 또는 색인 방식 사용)



파일 보호는 컴퓨터 시스템에서 데이터의 기밀성, 무결성, 가용성을 유지하기 위해 필수적인 기능

1. 물리적 보호 (Physical Protection)
물리적 보호는 하드웨어나 저장 장치에 대한 직접적인 보호를 의미하며, 데이터가 물리적으로 손상되거나 손실되는 것을 방지하는 데 중점을 둡니다.

2. 접근 보호 (Access Protection)
접근 보호는 데이터 및 시스템 자원에 대한 접근을 제어하여 무단 접근이나 데이터 손상을 방지하는 것입니다. ( 권한 사용 : r,w,x..)

디렉터리 구조(Directory Structure)는 파일 시스템에서 파일과 폴더(디렉터리)를 체계적으로 구성하여 관리하는 방법을 의미합니다. 디렉터리 구조는 파일에 대한 접근성을 향상시키고, 사용자가 파일을 쉽게 찾고 관리할 수 있도록 도와줍니다.


단일 디렉토리 : 하나의 디렉토리에 모두저장
- 구현이 간편하다.
- 모두 같은 디렉토리에 파일들이 저장되기에 파일명등의 제약이 크다.

2단계 디렉토리 : 사용자 별로 각각의 디렉토리를 가지는 구조

트리구조 디렉토리 : 디렉토리와 서브디렉토리의 계층적구조 (컴포지트 트리)

비순환구조 디렉토리 : 트리구조 디렉토리와 비슷하지만 각 디렉토리간 정보 공유가 가능