
- **연결그래프 (Connected Graph)**: 모든 정점들이 서로 연결되어 있는 그래프.
- **비연결그래프 (Disconnected Graph)**: 일부 정점들 간에 연결이 없는 그래프.
- **밀집그래프 (Dense Graph)**: 정점 수에 비해 간선이 많고, 대부분의 정점이 서로 연결된 그래프.
- **성긴 그래프 (Sparse Graph)**: 간선 수가 적고, 정점들이 상대적으로 적게 연결된 그래프.
- **방향그래프 (Directed Graph)**: 간선에 방향이 있어, 한 방향으로만 연결된 그래프.
- **무방향그래프 (Undirected Graph)**: 간선에 방향이 없고, 양방향으로 연결된 그래프.
- **가중치 그래프 (Weighted Graph)**: 간선에 가중치(비용)가 부여된 그래프.


#### DFS: Depth First Search
**스택**이나 **재귀 호출**을 사용하여 한 경로를 **깊게** 탐색한 후 막다른 길에서 **되돌아가는** 방식의 그래프 탐색 알고리즘

저자의 프로그램에서는 노드가 아닌 엣지를 사용하여 탐색
- 시작 노드를 표현하기 위해 **더미 엣지**(시작 노드 → 시작 노드)를 스택에 삽입
- ---
- 
```
template <class graph_type>
bool Graph_SearchDFS<graph_type>::Search()
{
  // std::stack 객체를 생성하여 엣지(Edge)를 저장할 스택을 만듭니다.
  std::stack<const Edge*> stack;

  // 더미 엣지를 생성하고 스택에 추가합니다. (시작 노드의 부모 역할)
  Edge Dummy(m_iSource, m_iSource, 0);
  
  stack.push(&Dummy);

  // 스택에 엣지가 존재하는 동안 계속 탐색합니다.
  while (!stack.empty())
  {
    // 스택의 가장 위에 있는 엣지를 가져옵니다.
    const Edge* Next = stack.top();

    // 스택에서 해당 엣지를 제거합니다.
    stack.pop();

    // 현재 엣지가 가리키는 노드의 부모를 기록합니다.
    m_Route[Next->To()] = Next->From();

    // 트리에 엣지를 추가합니다. (단, 더미 엣지는 트리에 추가하지 않습니다.)
    if (Next != &Dummy)
    {
      m_SpanningTree.push_back(Next);
    }
   
    // 해당 노드를 방문했다고 표시합니다.
    m_Visited[Next->To()] = visited;

    // 목표 노드에 도달하면 성공을 반환합니다.
    if (Next->To() == m_iTarget) return true;
    

    // 현재 노드에서 나가는 엣지들을 스택에 추가합니다.
    // (단, 아직 방문하지 않은 노드로 향하는 엣지만 추가합니다.)
    graph_type::ConstEdgeIterator ConstEdgeItr(m_Graph, Next->To());

    for (const Edge* pE = ConstEdgeItr.begin();
         !ConstEdgeItr.end();
         pE = ConstEdgeItr.next())
    {
      if (m_Visited[pE->To()] == unvisited) stack.push(pE);
    }
    
  }
  // 목표 노드로 가는 경로를 찾지 못했을 경우 false를 반환합니다.
  return false;
}
```
**DFS 동작흐름 예시**

1. 스택 초기화, 더미엣지 삽입,스택에 추가

스택이 빌때까지 반복(못찾고 끝나면 목표노드로 도달할수 없는것)
2. 스택의 가장 윗부분을 팝, 해당 엣지의 목표에 방문표시
3. 해당 엣지의 목표가 우리가 원하는 목표면 true 반환
   목표가 아니었다면 해당 엣지의 목표노드의 엣지들을 스텍에 추가

