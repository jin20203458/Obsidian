### CTU:교차 번역 단위 분석

**참조** :
[[ASTContext]]
[[Inter-procedural Analysis (IPA)]]

Inter-procedural Analysis (IPA)와 관련하여 "교차 번역 단위 분석 (Cross-Translation Unit Analysis)" 또는 줄여서 **CTU 분석**에 대해 설명해 드리겠습니다.

### 교차 번역 단위 분석 (Cross-Translation Unit Analysis, CTU 분석)

**CTU 분석**은 컴파일러가 프로그램을 최적화하거나 분석할 때, **하나의 소스 파일(번역 단위)을 넘어 여러 소스 파일(번역 단위)에 걸쳐 코드의 상호작용을 분석하는 기법**을 의미합니다.

**번역 단위(Translation Unit)란?**

일반적으로 C/C++ 같은 컴파일 언어에서 "번역 단위"는 `.c`, `.cpp` 파일 하나와 해당 파일이 `#include`하는 모든 헤더 파일을 합친 것을 말합니다. 각 번역 단위는 독립적으로 컴파일되어 오브젝트 파일(`.o` 또는 `.obj`)을 생성합니다.

**CTU 분석이 필요한 이유:**

대부분의 대규모 소프트웨어는 여러 개의 `.c` 또는 `.cpp` 파일로 구성됩니다. 각 파일은 독립적으로 컴파일되지만, 파일 내의 함수들은 다른 파일에 정의된 함수를 호출하거나, 다른 파일의 전역 변수를 참조할 수 있습니다.

예를 들어, `file1.c`에 정의된 `funcA()`가 `file2.c`에 정의된 `funcB()`를 호출하고, `funcB()`는 `file3.c`에 정의된 전역 변수 `g_val`을 수정한다고 가정해 봅시다.

- `file1.c`만 컴파일러가 분석할 때는 `funcB()`의 내부 동작을 알 수 없습니다.
    
- `file2.c`만 분석할 때는 `g_val`이 어디에 정의되어 있고 어떻게 사용되는지 전체적인 그림을 파악하기 어렵습니다.
    

이처럼 여러 파일에 걸친 함수 호출, 데이터 흐름, 변수 접근 등을 정확히 분석하고 최적화하려면 각 번역 단위의 경계를 넘어서는 분석이 필요하며, 이것이 바로 CTU 분석입니다.

### CTU 분석의 주요 목적

IPA와 마찬가지로 CTU 분석의 주된 목적도 **더 강력한 최적화**와 **더 정확한 정적 분석**을 가능하게 하는 것입니다.

1. **컴파일러 최적화:**
    
    - **링크 타임 최적화 (Link-Time Optimization, LTO):** CTU 분석의 가장 대표적인 적용 사례입니다. 각 소스 파일을 개별적으로 컴파일하여 오브젝트 파일을 생성한 후, 링커 단계에서 프로그램 전체를 하나의 큰 번역 단위처럼 다시 분석하고 최적화합니다. 이를 통해 함수 인라이닝, Dead Code Elimination, 상수 전파 등을 여러 파일에 걸쳐 수행하여 최종 실행 파일의 성능을 크게 향상시킬 수 있습니다.
        
    - **함수 인라이닝 (Inter-file Inlining):** 다른 파일에 정의된 작은 함수를 호출하는 곳에 직접 코드를 삽입하여 함수 호출 오버헤드를 줄입니다.
        
    - **불필요 코드 제거 (Inter-file Dead Code Elimination):** 어떤 번역 단위에서도 호출되지 않는 함수나 사용되지 않는 전역 변수를 프로그램 전체에서 찾아 제거합니다.
        
    - **콜 그래프 구축 (Global Call Graph Construction):** 프로그램 전체의 정확한 함수 호출 그래프를 구축하여 더 정교한 분석 및 최적화를 가능하게 합니다.
        
2. **정적 코드 분석:**
    
    - **정확한 오류 및 취약점 탐지:** 단일 파일 분석으로는 놓칠 수 있는, 파일 간 상호작용으로 인해 발생하는 복잡한 버그(예: 메모리 누수, 잘못된 자원 해제, 보안 취약점의 데이터 흐름)를 탐지합니다.
        
    - **전역 데이터 흐름 분석:** 전역 변수나 정적 변수가 여러 파일에 걸쳐 어떻게 사용되고 변경되는지 추적하여 예측 불가능한 동작이나 경쟁 조건을 찾아냅니다.
        
    - **API 오용 감지:** 라이브러리 함수(API)가 여러 파일에 걸쳐 잘못된 순서나 방식으로 호출될 때를 감지합니다.
        

### CTU 분석의 구현 방식 및 도전 과제

- **다단계 분석:**
    
    1. 각 번역 단위를 독립적으로 초기 컴파일하여 중간 표현(IR, Intermediate Representation)을 생성합니다.
        
    2. 이 중간 표현들을 모두 모아 프로그램 전체에 대한 정보를 수집하고 분석합니다.
        
    3. 수집된 정보를 바탕으로 최적화된 코드를 다시 생성하거나, 분석 결과를 보고합니다.
        
- **파일 종속성 관리:** 여러 파일 간의 복잡한 의존성 관계를 효율적으로 관리해야 합니다.
    
- **확장성(Scalability):** 대규모 코드베이스에서는 모든 번역 단위를 한 번에 분석하는 것이 엄청난 메모리 및 CPU 자원을 요구할 수 있습니다.
    
- **빌드 시스템 통합:** CTU 분석을 기존 빌드 시스템(Make, CMake 등)에 통합하는 것이 복잡할 수 있습니다. LTO의 경우 컴파일러와 링커 모두의 지원이 필요합니다.
    

### 요약

CTU 분석은 IPA의 확장된 개념으로 볼 수 있습니다. IPA가 주로 함수 호출 경계를 넘는 분석을 의미한다면, CTU 분석은 한 단계 더 나아가 **소스 코드 파일 경계까지 넘어서는 분석**을 의미합니다. 이는 컴파일러가 더 나은 성능의 실행 파일을 만들고, 정적 분석 도구가 더 정확하고 포괄적인 결함을 찾아내는 데 필수적인 고급 분석 기법입니다.