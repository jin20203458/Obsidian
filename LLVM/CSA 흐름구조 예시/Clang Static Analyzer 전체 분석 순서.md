
## 1. **AST와 CFG 생성**

- **AST(Abstract Syntax Tree)**:  
    소스 코드를 파싱해서 **프로그램의 구조**(문장, 표현식 등)를 트리로 만듭니다.
    
- **CFG(Control Flow Graph)**:  
    AST를 기반으로 **프로그램의 실행 흐름**(분기, 반복, 함수 호출 등)을 그래프로 만듭니다.
    

## 2. **분석 엔진의 순회(실행 흐름 따라가기)**

- 분석 엔진은 **CFG를 따라가며** 프로그램이 실제로 실행되는 것처럼 한 줄씩(혹은 한 블록씩) 이동합니다.
    
- 각 CFG 노드(= 코드의 한 지점)에서 **"지금까지의 상태**"를 나타내는 **Exploded Node**를 참고합니다.
    

## 3. **AST 노드 평가와 콜백 호출**

- CFG의 각 지점에는 **AST 노드**(문장, 표현식 등)가 연결되어 있습니다.
    
- 엔진이 CFG의 한 지점에 도달하면,  
    해당 지점의 **AST 노드를 평가**합니다.
    
- 이때, **체커**(Checker)의 콜백 함수가  
    (예: `checkPostStmt<ArraySubscriptExpr>`, `checkPreCall` 등)  
    **해당 AST 노드 기준으로 호출**됩니다.
    

## 4. **Exploded Node(상태 노드)의 역할**

- **Exploded Node**는
    
    - "이 코드 위치에서의 실행 상태(메모리, 변수 값, 심볼 등)"
        
    - "프로그램 실행 위치(ProgramPoint)"  
        를 모두 저장하는 **스냅샷**입니다.
        
- 엔진은 **현재 Exploded Node**를 기반으로
    
    - AST 노드를 평가하고,
        
    - 체커 콜백에 인수로 전달하며,
        
    - 상태 변화가 생기면 **새로운 Exploded Node**를 생성합니다.
        

## 5. **전체 흐름 요약**

1. **소스 → AST → CFG 생성**
    
2. **엔진이 CFG를 따라가며**
    
3. **각 지점에서 AST 노드 평가**
    
4. **현재 Exploded Node(상태)를 참고**
    
5. **체커 콜백 호출 및 상태 변화 처리**
    
6. **필요 시 새로운 Exploded Node 생성, 분석 경로 확장**
    

## **비유로 쉽게 설명**

- **CFG**: 프로그램의 "미래 지도"
    
- **AST**: 각 지점에서 "무슨 코드가 있는지" 설명서
    
- **Exploded Node**: "지금까지 어떻게 왔는지" 기록된 상태 스냅샷
    
- **분석 엔진**:
    
    1. 미래 지도(CFG)를 따라가며
        
    2. 각 지점의 코드(AST)를 해석하고
        
    3. 현재 상태(Exploded Node)를 참고해서
        
    4. 체커로 분석/경고/상태 변화를 처리
        

## **정리**

- **CFG를 따라가며 → AST를 평가하고 → Exploded Node(상태)를 참고/갱신**  
    이 순서가 Clang Static Analyzer의 핵심 분석 흐름입니다.
    
- 세 가지가 **동시에 맞물려 돌아간다**고 이해하면 좋습니다.
    