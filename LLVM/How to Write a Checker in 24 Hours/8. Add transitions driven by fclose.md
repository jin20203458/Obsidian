# Register for `fclose()` — `check::PreCall`을 사용하는 이유

---

## 🧠 먼저 구조부터

```cpp
class SimpleStreamChecker : public Checker< check::PostCall,      // fopen용 
                                            check::PreCall > {    // fclose용

public:  
void checkPostCall(const CallEvent &Call, CheckerContext &C) const; // fopen 
void checkPreCall(const CallEvent &Call, CheckerContext &C) const;  // fclose 
};`
```


- `check::PostCall`: **함수 호출 직후** 개입 가능 → `fopen()` 분석에 적합
- `check::PreCall`: **함수 호출 직전** 개입 가능 → `fclose()` 분석에 적합

 왜 `fclose()`는 `PreCall`에서 처리하나?

>**실행하기 전에**,  
  해당 핸들이 **정말 열려 있는지**를 미리 확인하고 싶기 때문입니다.


```cpp
void SimpleStreamChecker::checkPreCall(const CallEvent &Call, 
                                              CheckerContext &C) const { 

// Prototype for fclose is 
// int fclose(FILE *FileDesc); 
if (!Call.isGlobalCFunction("fclose") || Call.getNumArgs() != 1) return; 

// Get the symbolic value corresponding to the file handle. 
SymbolRef FileDesc = Call.getArgSVal(0).getAsSymbol(); 
//fclose(fp)에서 첫 번째 인자인 fp를 가져옵니다.

//getAsSymbol()이 실패하면 → 이 값은 추적 불가능한 값
if (!FileDesc) return;

// Generate the next transition, in which the stream is closed.
// 상태가 바뀌었으니, 분석 경로 그래프에 새 노트(edge)를 추가합니다.
ProgramStateRef State = C.getState(); 
State = State->set(FileDesc, StreamState::getClosed());
C.addTransition(State); 
}
```
