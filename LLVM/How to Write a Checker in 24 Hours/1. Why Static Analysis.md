
### 1. **"Explores each path through the program" 
(프로그램의 각 경로를 탐색합니다)**

- 정적 분석기는 코드가 실행될 수 있는 **모든 가능한 시나리오(경로)**를 하나하나 따라가며 분석합니다.
- 이는 단순히 코드의 한 부분을 보는 것이 아니라, 전체적인 데이터와 제어 흐름이 어떻게 연결되는지를 파악하는 데 중요합니다.

### **2. "Path-sensitive, context-sensitive analysis" 
(경로 민감, 문맥 민감 분석)**

- **경로 민감 (Path-sensitive)**: 위에서 설명했듯이, 프로그램의 특정 지점에서 변수의 값이 **어떤 경로를 통해 그 지점에 도달했는지에 따라 다르게 분석**합니다. 예를 들어, `if` 문을 통과한 후의 변수 값과 `else` 문을 통과한 후의 변수 값을 다르게 인식하고 분석을 이어갑니다. 앞서 `LogHandle` 예시에서 `WriteToLog` 값에 따라 `LogHandle`의 초기화 여부가 달라지는 것을 정확히 추적하는 것이 경로 민감 분석입니다.

- **문맥 민감 (Context-sensitive)**: 함수를 호출할 때, **어떤 호출 지점(문맥)에서 호출되었는지에 따라 함수 내부의 분석 결과가 달라질 수 있음**을 의미합니다. 예를 들어, 동일한 함수 `foo(int x)`라도 `foo(5)`로 호출되었을 때와 `foo(10)`으로 호출되었을 때, 함수 내부의 `x` 값에 따른 동작을 다르게 모델링하여 분석합니다. 이는 특히 재귀 함수나 동일한 함수가 여러 곳에서 다양한 인수로 호출될 때 중요합니다.

- **즉**: 정적 분석은 단순히 구문적인 오류를 찾는 것을 넘어, 프로그램의 복잡한 실행 흐름과 함수 호출 문맥을 이해하여 더 정확하고 깊이 있는 분석을 수행합니다.

### 3. "Algorithm is exponential (but bounded)" 
**(알고리즘은 지수적이지만 (제한적입니다))**
- **지수적(Exponential)**: 경로 민감 분석은 프로그램의 가능한 모든 경로를 탐색하기 때문에, 경로의 수가 늘어나면 분석해야 할 경우의 수가 기하급수적으로(지수적으로) 증가한다는 의미입니다. 이는 이론적으로 매우 많은 시간과 메모리를 요구할 수 있습니다. 예를 들어, `if-else` 구문이 n개 있다면 2n개의 경로가 생길 수 있습니다.  

- **제한적(but bounded)**: 하지만 실제 정적 분석 도구들은 이러한 지수적인 증가를 완화하기 위한 다양한 최적화 기법(예: 경로 병합, 상태 추상화, 깊이 제한, 시간 제한 등)을 사용합니다. 따라서 이론적으로는 복잡하지만, 실제로는 어느 정도의 합리적인 시간 내에 분석을 완료할 수 있도록 제한(bound)을 둔다는 의미입니다. 모든 무한한 경로를 다 탐색하는 것이 아니라, 특정 기준에 따라 탐색 범위를 제한하여 실용성을 확보합니다.

- **즉**: 정적 분석은 강력한 대신 계산 비용이 높을 수 있지만, 실제 사용을 위해 이 비용을 제어하는 기술이 적용된다는 뜻입니다.

### 4. "Produces very precise results" 
**(매우 정밀한 결과를 생성합니다)**

- 위에서 언급한 경로 민감, 문맥 민감 분석 덕분에 정적 분석기는 **오탐(False Positive, 실제 버그가 아닌데 버그로 보고하는 경우)**이나 **미탐(False Negative, 실제 버그인데 발견하지 못하는 경우)**의 비율을 줄여서 **정확도가 높은 결과**를 제공합니다.

### **5. "Able to find more bugs" (더 많은 버그를 찾을 수 있습니다)**

- **무슨 소리?**: 단순한 컴파일러 경고나 코드 리뷰로는 발견하기 어려운, **런타임에만 드러나는 복잡한 유형의 버그**를 정적 분석이 찾아낼 수 있다는 의미입니다.
  **ex)**  
    - **use-after-free (해제 후 사용)**: 이미 해제(free)된 메모리 영역을 다시 접근하여 사용하는 버그입니다. 이는 런타임에 프로그램 크래시나 보안 취약점으로 이어질 수 있으며, 복잡한 메모리 할당/해제 흐름을 추적해야 발견할 수 있습니다.
        
    - **resource leaks (자원 누수)**: 파일 핸들, 네트워크 소켓, 데이터베이스 연결 등과 같은 시스템 자원을 할당받은 후 사용이 끝났는데도 제대로 해제하지 않아 자원이 계속 점유되는 문제입니다. 장기 실행 프로그램에서 성능 저하나 시스템 불안정을 유발할 수 있습니다.
        
    - `...`: 이 외에도 다양한 유형의 런타임 오류나 잠재적 취약점(예: 널 포인터 역참조, 배열 범위 초과 접근, 경쟁 조건 등)을 찾아낼 수 있다는 뜻입니다.



정적 분석이 단순히 코드의 표면적인 문제를 넘어, **프로그램의 모든 가능한 실행 경로와 문맥을 심층적으로 탐색**하여 **매우 정밀하고 정확한 결과를 제공**하며, 이를 통해 **컴파일 시점이나 단순한 테스트로는 발견하기 어려운 복잡하고 치명적인 런타임 버그들을 효과적으로 찾아낼 수 있는 강력한 도구입니다.

### EX)

```C
void writeCharToLog(char *Data) {
    FILE *F = fopen("my_log.txt", "w");
    
    if (F != NULL) {
        if (!Data)
            return;

        fputc(*Data, F);
        fclose(F);
    }

    return;
}
```

![[Pasted image 20250630110530.png]]

- Data가 null 이라고 가정하면 if 문은 즉시 반환됩니다. 
- 함수가 Early Return 되면 운영 체제 자원(열린 파일과 관련된 파일 디스크립터)이 해제되지 않습니다. 이런 상황이 반복된다면 자원 고갈을 초래합니다.
