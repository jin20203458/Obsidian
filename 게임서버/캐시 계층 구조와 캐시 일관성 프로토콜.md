###  **L1, L2, L3 캐시와 Store Buffer,WriteBuffer의 역할과 관계**

|**구성 요소**|**역할**|**위치**|**크기**|**속도**|
|---|---|---|---|---|
|**L1 캐시**|데이터와 명령어를 저장, 가장 빠르게 접근 가능한 저장소|CPU 코어 내부|32KB~64KB|가장 빠름 (몇 사이클 내)|
|**L2 캐시**|L1 캐시의 미스를 보완하며, 더 큰 데이터 저장|CPU 코어 내부 또는 공유|256KB~2MB|L1보다 느림 (수십 사이클)|
|**L3 캐시**|모든 코어가 공유하며, 캐시 미스가 발생한 데이터를 제공|CPU 다이 내부 공유|몇 MB~수십 MB|L2보다 느림 (수백 사이클)|
|**Store Buffer**|쓰기 작업 임시 저장소로, 캐시와 메모리로 데이터 전달을 최적화|CPU 코어 내부|몇 엔트리 (작음)|쓰기 작업 속도를 최적화|
|**Write Buffer**|캐시에서 메모리로 쓰기 작업을 병합하고 최적화|캐시와 메모리 사이|몇 KB (작음)|메모리 쓰기보다 빠름, 캐시보다 느림|
데이터 쓰기 흐름은 기본적으로 **Store Buffer → L1 → L2 → L3 → Write Buffer → 메모리** 순서로 진행됩니다.
- 이는 CPU의 메모리 정책(예: Write-back vs Write-through)에 따라 달라질수 있습니다.
    -  **Write-back**: 캐시에서 데이터를 수정하고, 캐시가 교체되거나 필요할 때만 메모리에 데이터를 반영하는 방식.
     - **Write-through**: 데이터를 수정할 때마다 캐시와 메모리 모두에 동시에 기록하는 방식.

- CPU에서 **쓰기 작업을 캐시에 저장하지 않고 바로 메모리로 전달**해야 하는 경우, 데이터가 Store Buffer에서 캐시를 건너뛰고 Write Buffer로 이동하기도 합니다. (예: 캐시 비활성화 작업이나 I/O 데이터 전송 시).
```
CPU 
└─ Store Buffer 
       └─ L1 Cache 
            └─ L2 Cache 
                 └─ L3 Cache 
                      └─ Write Buffer 
                          └─ Main Memory (RAM)
```
## **데이터 흐름 순서**

1. **Store Buffer**:
    
    - **CPU와 L1 캐시 사이**에 위치.
    - CPU가 데이터를 쓰려는 요청을 Store Buffer에 임시 저장.
    - Store Buffer는 데이터를 L1 캐시로 전달하거나, L1 캐시가 꽉 차 있거나 정책에 따라 L2/L3 캐시나 memory로 전달.
2. **L1, L2, L3 캐시**:
    
    - Store Buffer에서 전달받은 데이터는 **L1 캐시**로 기록되며, 필요에 따라 L2/L3 캐시로 전파.
    - 캐시 일관성을 유지하기 위해 L1~L3 간에 데이터가 교환됨.
3. **Write Buffer**:
    
    - **캐시(L1/L2/L3)와 메모리 사이**에 위치.
    - 캐시가 데이터를 메모리에 기록해야 할 경우, Write Buffer에 임시 저장.
    - Write Buffer는 데이터를 병합하거나 쓰기 순서를 최적화하여 메모리에 기록.
4. **메모리(RAM)**:
    
    - Write Buffer에서 데이터를 받아 최종적으로 메모리에 기록.


## MESI Protocol
- 다중 캐시가 존재하는 멀티프로세서 시스템에서 캐시 일관성을 유지하기 위한 **캐시 동기화 프로토콜**
- 캐시의 각 라인(데이터 블록)의 상태를 나타내는 **4가지 상태**로 구성: **Modified**, **Exclusive**, **Shared**, **Invalid**. 
-  **캐시 일관성**을 보장하고 여러 캐시가 동일한 데이터를 효율적으로 공유의 목적을 지님
- 본 프로토콜은 cpu의 로컬 캐시인 주로 L1,L2에서 동작합니다.
### **MESI 프로토콜의 4가지 상태**

1. **Modified (M)**:
    
    - **상태**: 이 캐시는 해당 데이터 블록을 수정한 유일한 캐시입니다. 캐시 내의 데이터는 **메모리와 일치하지 않으며**, 캐시 내 데이터는 최신 상태입니다.
    - **특징**: 데이터가 메모리에 아직 기록되지 않았습니다. 따라서 해당 캐시는 **수정된 데이터의 유일한 소스**입니다.
    - **상호 작용**: 이 캐시가 데이터를 수정하고, 다른 캐시들이 데이터를 요청하면 해당 데이터를 메모리로 기록하기 전에 **다른 캐시들을 무효화**합니다.
2. **Exclusive (E)**:
    
    - **상태**: 이 캐시가 데이터를 **수정할 수 있으며**, 현재 데이터는 다른 캐시에는 없고, **메모리와 동일**합니다.
    - **특징**: 데이터는 메모리에서 읽어온 것이며, 이 캐시는 해당 데이터에 대한 **유일한 소유자**입니다. 캐시가 데이터를 수정하기 시작할 수 있습니다.
    - **상호 작용**: 데이터가 수정될 경우, 이 캐시는 **Modified** 상태로 전환됩니다. 만약 다른 캐시가 이 데이터를 요청하면, 해당 캐시는 **Shared** 상태로 전환될 수 있습니다.
3. **Shared (S)**:
    
    - **상태**: 캐시가 이 데이터를 **다른 캐시와 공유**하고 있으며, 이 데이터는 **메모리와 일치**합니다.
    - **특징**: 여러 캐시가 이 데이터를 공유하고 있고, 캐시 내 데이터는 수정되지 않았습니다. 모든 캐시가 메모리와 일치하는 데이터를 가집니다.
    - **상호 작용**: 다른 캐시에서 데이터를 수정하거나 이 데이터를 요청하면, 이 캐시는 **Invalid** 상태로 전환됩니다. 데이터를 수정하려는 캐시가 있을 경우, 해당 캐시는 데이터를 수정하기 전에 데이터를 **Invalid** 상태로 전환해야 합니다.
4. **Invalid (I)**:
    
    - **상태**: 캐시가 **유효하지 않은 데이터**를 가지고 있습니다. 해당 캐시 라인은 더 이상 의미가 없으며, 캐시가 최신 데이터를 가질 필요가 있습니다.
    - **특징**: 데이터가 수정되었거나 캐시가 데이터의 최신 상태를 가지고 있지 않음을 나타냅니다.
    - **상호 작용**: 캐시가 **Invalid** 상태일 때, 해당 데이터를 다시 읽어와야 하며, 새로 데이터를 요청하거나 캐시 일관성을 유지하는 동작을 해야 합니다.

---
### **MESI 프로토콜 사용 예시**

#### **상황 1: 데이터 읽기 (Read Miss)**

1. **CPU A**가 **메모리**에서 데이터를 읽으려고 합니다. 이 데이터는 **L1 캐시**에 없습니다.
    
2. **CPU A**는 **L1 캐시**에서 데이터를 찾을 수 없으므로 **L2 캐시**로 데이터를 요청하고, 여전히 없다면 **메모리**에서 데이터를 읽어옵니다.
    
3. **CPU A**가 데이터를 읽은 후, 그 데이터는 **Exclusive (E)** 상태로 **L1 캐시**에 저장됩니다.
    
    - **Exclusive (E)** 상태: 데이터는 **메모리와 일치**하며, 현재 **이 캐시만** 해당 데이터를 가지고 있습니다. 데이터는 아직 수정되지 않았고, 다른 캐시에는 없습니다.
4. 만약 **CPU B**도 동일한 메모리 주소를 참조한다면, **CPU B**는 데이터를 **Shared (S)** 상태로 캐시할 수 있습니다. **CPU B**는 데이터를 읽고, 다른 캐시들이 이 데이터를 공유하며, 데이터는 여전히 메모리와 일치합니다.
    
    **관점**: 이 과정에서는 데이터가 **Shared** 상태로 여러 캐시에서 공유되고 있으며, 메모리와 일치합니다.
    

#### **상황 2: 데이터 수정 (Write Miss)**

1. **CPU A**가 데이터를 수정하려고 합니다. 이 데이터는 **L1 캐시**에서 **Shared (S)** 상태로 존재합니다.
    
2. **CPU A**는 데이터를 수정하면, 해당 **L1 캐시**의 상태는 **Modified (M)**로 전환됩니다.
    
3. **CPU B**가 동일한 데이터에 접근하려고 하면, **CPU B**의 캐시는 **Invalid (I)** 상태로 전환됩니다.
    
4. **CPU A**가 데이터를 **메모리**에 쓰지 않은 상태에서는, 다른 CPU들이 이 데이터를 읽을 수 없습니다. **CPU A**는 데이터가 변경되었음을 메모리로 반영하지 않습니다.
    
    **관점**: **CPU A**가 데이터를 수정하면서 **Modified (M)** 상태로 변경되고, **CPU B**는 해당 데이터를 **Invalid (I)** 상태로 마킹합니다. 이는 데이터 일관성을 보장하기 위해 중요한 과정입니다.
    

#### **상황 3: 데이터 수정 후 메모리 업데이트 (Write-back)**

1. **CPU A**가 **L1 캐시**에서 데이터를 수정하여 **Modified (M)** 상태로 두었습니다.
    
2. **CPU A**가 데이터를 **다시 읽으려고** 하거나 **캐시 교체**가 발생할 때, 해당 데이터는 **메모리**에 반영됩니다.
    
3. 데이터가 **메모리**로 **백업**된 후, 다른 캐시들이 이 데이터를 다시 읽을 수 있습니다. 다른 캐시들은 해당 데이터를 **Shared (S)** 상태로 가지고 있을 수 있습니다.
    
    **관점**: **Modified (M)** 상태의 데이터를 메모리에 반영하여, 다른 캐시들이 최신 데이터를 사용할 수 있도록 합니다.
    

#### **상황 4: 데이터 교체 (Eviction)**

1. **CPU A**의 **L1 캐시**가 데이터를 수정한 후, **캐시 교체**가 일어날 수 있습니다.
    
2. 이때, **CPU A**는 수정된 데이터를 **메모리**에 반영하지 않고, **Modified (M)** 상태로 데이터를 **L2 캐시**나 **메모리**에 반영할 수 있습니다.
    
3. **CPU B**가 동일한 데이터를 읽으려고 하면, **CPU B**의 캐시는 **Invalid (I)** 상태로 전환되고, **CPU B**는 최신 데이터를 다시 읽어야 합니다.
    
    **관점**: 캐시가 교체될 때, 수정된 데이터가 **메모리**에 반영되어야 하고, 다른 캐시는 해당 데이터를 최신 상태로 가져오게 됩니다.


**결론** : 캐시 일관성은 모든 프로세서가 최신의 정보를 공유하는것으로 이는 캐시 지역성과도 밀접한 관련이 있습니다. 이는 데이터 정확성과 안정성, 캐시히트에 매우 중요한 역할을 합니다. 