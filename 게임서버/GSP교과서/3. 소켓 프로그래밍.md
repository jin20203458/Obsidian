### **1. 블로킹 소켓 (Blocking Socket)**

블로킹 소켓은 **소켓의 작업이 완료될 때까지 다른 작업을 차단**하는 방식입니다. 즉, **읽기/쓰기 작업**이 완료될 때까지 호출한 스레드가 기다립니다.

#### **특징**

- **읽기 작업**: 데이터를 받을 준비가 되지 않으면 소켓은 **대기 상태**에 들어가고, 데이터가 준비될 때까지 기다립니다.
- **쓰기 작업**: 데이터가 전송될 준비가 될 때까지 소켓은 **대기 상태**에 들어갑니다. 즉, 데이터를 모두 전송할 때까지 기다립니다.
- 주로 **단순한 서버/클라이언트 구조**에서 사용됩니다.
- 동기적(Synchronous) 방식으로 동작합니다.



### **2. 논블로킹 소켓 (Non-blocking Socket)**

논블로킹 소켓은 **읽기/쓰기 작업**을 요청했을 때, 작업이 **완료되지 않았다고 하더라도 즉시 반환**합니다. 즉, **데이터가 준비되지 않으면 바로 반환하고**, **데이터 준비가 되면 다시 확인하는 방식**입니다.

#### **특징**

- **읽기 작업**: 데이터가 준비되어 있지 않으면, 소켓은 **대기하지 않고 즉시 반환**하며, 애플리케이션은 다시 소켓을 확인하여 데이터가 준비되었는지 확인합니다.
- **쓰기 작업**: 데이터가 준비되었는지 즉시 확인하고, 준비되지 않았다면 즉시 반환합니다.
- **폴링(Polling)** 방식으로 자주 사용되며, **select()**나 **poll()** 같은 함수와 결합해 사용됩니다.
- 비동기적(Asynchronous) 방식으로 동작합니다.

-------------
### 🔑 **`select()`란?**

`select()`는 **다수의 소켓(파일 디스크립터)을 동시에 감시하여, 읽기, 쓰기, 예외 상황**이 발생했는지 여부를 체크합니다.

즉, 여러 개의 소켓 중에서 **데이터가 준비된 소켓만 처리**하도록 만들어 CPU 사용률을 높이고 불필요한 대기를 줄입니다.
```
int select( 

int nfds,                 // 감시할 파일 디스크립터의 개수 
fd_set *readfds,          // 읽기 이벤트 감시 소켓 리스트 
fd_set *writefds,         // 쓰기 이벤트 감시 소켓 리스트 
fd_set *exceptfds,        // 예외 이벤트 감시 소켓 리스트
struct timeval *timeout   // 타임아웃 값 (NULL이면 무한 대기) 

);
```
### ✅ **select() 모델 원리**

👉 select() 모델은 **I/O 멀티플렉싱 방식**입니다.
Polling

**동작 과정**:

1. **모든 소켓을 리스트에 등록**합니다.
2. `select()` 함수가 리스트에 등록된 모든 소켓을 **폴링(Polling)** 방식으로 감시합니다.
3. 소켓에 데이터가 준비되었거나 연결이 끊어진 경우에만 반환합니다.
4. 반환된 소켓만 데이터 송수신 작업을 수행합니다.

### 🔑 **핵심 원리**

- CPU가 모든 소켓을 **동기적으로 검사**합니다.
- 데이터가 없는 소켓도 검사하기 때문에 **불필요한 자원 소모**가 발생합니다.
- 다수의 클라이언트가 접속하면 성능이 **급격히 저하**됩니다.

---
## ✅ 2. **WSAEventSelect 방식**

### 🔑 **원리**

WSAEventSelect는 **I/O 멀티플렉싱 기반의 비동기 모델**입니다.

👉 select() 모델처럼 **Polling 방식**을 사용하지만, 이벤트 객체를 통해 상태를 감시합니다.

---

### **Overlapped I/O 모델 설명 (Windows 비동기 소켓 프로그래밍)**

### ✅ **Overlapped I/O 모델 원리**

👉 Overlapped I/O는 **비동기 소켓 통신 방식**입니다.
Event-driven (이벤트 기반)

**동작 과정**:

1. 클라이언트로부터 데이터를 수신할 때 **WSARecv()** 함수를 호출하고, 작업 요청만 한 뒤 바로 반환합니다.
2. 작업이 완료되면 **이벤트 객체(Event Object)**가 시그널 상태로 변경됩니다.
3. `WSAWaitForMultipleEvents()` 함수가 이벤트 객체를 감시합니다.
4. 시그널 상태가 된 이벤트 객체만 처리합니다.
5. 작업 완료 여부는 **WSAGetOverlappedResult()** 함수로 확인합니다.

### 🔑 **핵심 원리**

- 작업을 요청만 하고 바로 반환하므로 CPU가 다른 작업을 수행할 수 있습니다.
- 데이터가 준비된 소켓만 처리하기 때문에 **불필요한 자원 소모가 없음**.
- 클라이언트 수가 많아도 **성능 저하가 거의 없음**.

----

