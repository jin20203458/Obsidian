프로그램(코드,데이터:디스크에 위치) -> 실행(메모리적제) 
-> 프로세스(코드,힙,데이터,스텍:메모리에 위치)

하나의 프로세스는 하나 이상의 스레드를 가진다.
OS는 프로세스 테이블을 통해 프로세스를 관리하고,
프로세스 테이블은 프로세스ID와 PCB 형태로 저장되어있다.
PCB는 본인이 포함하는 스레드들의 TCB를 가진다.

PCB (Process Control Block) : 프로세스를 관리하기 위한 데이터 구조(TCB를 참조함)
TCB (Thread Control Block) : 스레드를 관리하기 위한 데이터 구조

- 프로세스는 OS가 관리하는 추상적 단위이다.
- 스레드는 cpu가 작업을 처리하는 기본단위이다.(CPU는 프로세스에 대하여 알지 못한다.)



싱글스레드 모델, 멀티스레드 모델

멀티 스레드 모델은 임계영역 문제를 가짐

이때 필요한게 mutex (mutual exclusion)


`std::lock_guard`는 C++에서 **여러 스레드가 동시에 하나의 자원에 접근할 때 생길 수 있는 문제**를 안전하게 막아주는 도구 
- 해당 객체가 생성될때 잠기고 소멸할때 해제됨

cpu 코어는 여러개라도 결국 하나의 메모리에 접근, 이시간을 메모리 바운드 시간이라함, (이때 cpu개수보다 더 적은수의 cpu로 처리됨)

뮤텍스가 너무 크다면 싱글스레드와 다름이 없고, 너무 작다면 복잡성이 커지며 데드락 문제를 야기할수있다.(적당한 단위가 중요)


이벤트 : 잠자는 스레드를 깨우는 도구
- Reset : 이벤트가 없음 0
- Set : 이벤트가 있음 1

- **자동 이벤트 (Auto-Reset Event)**: 이벤트가 신호 상태가 되면 대기 중인 하나의 스레드만 깨우고 자동으로 비신호 상태로 전환되는 동기화 도구.
- **수동 이벤트 (Manual-Reset Event)**: 이벤트가 신호 상태가 되면 대기 중인 모든 스레드를 깨우고, 명시적으로 비신호 상태로 전환될 때까지 유지되는 동기화 도구.

세마포(Semaphore)는 스레드 간의 동기화를 위해 사용하는 객체로, **자원에 접근할 수 있는 스레드의 수**를 제한합니다. `wait()` 또는 `acquire()`로 자원을 요청하고, 세마포 값이 0이면 대기 상태에 들어갑니다. `release()`는 세마포 값을 증가시키며 대기 중인 스레드를 깨우는 역할을 합니다.


#### 원자조작
