
**교착상태(Deadlock)란, 둘 이상의 프로세스나 스레드가 서로 자원을 점유한 채, 서로의 자원을 기다리느라 더 이상 진행할 수 없는 상태를 의미합니다.  
서로가 가진 자원을 상대방이 해제해주기를 기다리지만, 어느 쪽도 자원을 놓지 않으므로 시스템이 무한 대기 상태**에 빠집니다.

주의)
**기아상태(Starvation)란, 프로세스나 스레드가 자원 할당의 우선순위나 스케줄링 정책 때문에 무기한 자원을 획득하지 못하는 상태**를 의미합니다.  
이는 시스템이 특정 프로세스에만 자원을 계속 할당하거나, 우선순위가 낮은 프로세스를 무시할 때 발생할 수 있습니다.


### 차이점

- **영구 정지 여부**: 교착상태는 여러 프로세스가 서로 자원을 기다리면서 시스템 전체가 정지하지만, 기아는 특정 프로세스만 대기하고 다른 작업은 계속 진행됩니다.
- **원인**: 교착상태는 자원 상호 의존에 의해 발생하며, 기아는 자원 할당 우선순위 불균형(OS의 잘못된 정책) 때문에 발생합니다.

**교착 상태 발생 조건**

1. 상호배제: 한 프로세스가 사용하는 자원을 다른 프로세스가 사용불가능 상태
2. 점유와 대기: 자원을 할당받고 나머지 자원의 할당을 기다리는 상태
3. 비선점: 다른 프로세스의 자원을 뺏을수 없는 상태
4. 원형 대기: 자원을 기다리며 원형으로 서로를 대기하는 상태

**4가지 조건중 하나라도 만족하지 않는다면 교착상태는 발생 x 모두 만족하면 발생가능**


```
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

using namespace std;

mutex mutex1;
mutex mutex2;

void threadFunc1() {
    cout << "스레드 1: mutex1을 잠급니다...\n";
    mutex1.lock();
    cout << "스레드 1: mutex1 잠금 완료.\n";

    // 잠시 대기하여 다른 스레드가 실행될 수 있도록 함
    this_thread::sleep_for(chrono::milliseconds(100));

    cout << "스레드 1: mutex2를 잠급니다...\n";
    mutex2.lock();
    cout << "스레드 1: mutex2 잠금 완료.\n";

    cout << "스레드 1: 두 mutex 모두 획득했습니다.\n";

    // 임계 구역 종료 후 mutex 해제
    mutex2.unlock();
    mutex1.unlock();
}

void threadFunc2() {
    cout << "스레드 2: mutex2를 잠급니다...\n";
    mutex2.lock();
    cout << "스레드 2: mutex2 잠금 완료.\n";

    // 잠시 대기하여 다른 스레드가 실행될 수 있도록 함
    this_thread::sleep_for(chrono::milliseconds(100));

    cout << "스레드 2: mutex1을 잠급니다...\n";
    mutex1.lock();
    cout << "스레드 2: mutex1 잠금 완료.\n";

    cout << "스레드 2: 두 mutex 모두 획득했습니다.\n";

    // 임계 구역 종료 후 mutex 해제
    mutex1.unlock();
    mutex2.unlock();
}

int main() {
    thread t1(threadFunc1);
    thread t2(threadFunc2);

    t1.join();
    t2.join();

    cout << "프로그램 종료.\n";
    return 0;
}

```

#### 해결법

#### **예방  : 애초에 교착 상태가 발생하지 않도록 발생조건을 없애버림**
- 공유자원 문제 때문에 상호배제를 제외한
- 하벤더(Havender)가 제시한 방안

점유와 대기방지 : 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않음
- 자원이 없어야만 요청이 가능하게
- 자원의 활용율 저하

비선점방지 : 자원을 선점가능하게 
- 요구가 거절당하면 가진 자원을 반납하게(반납된 자원은 다른놈이 씀:선점)
- 모든 자원이 선점가능하지 않음
- 중간 처리물등이 무효화되며 효율성 격하

횐형대기방지 : 모든자원에 번호를 붙이고 오름차순으로 할당
- 꼬리가 머리를 무는 현상을 방지함 
- 자원에 번호를 붙이는것은 쉬운작업이 아니다.


- 피터슨 알고리즘이 예방 방법중 하나

#### **회피: 교착상태가 발생할꺼 같으면 자원할당 X** 

- 교착 상태를 무분별한 자원할당으로 인해 발생했다고 간주
- 시스템이 교착상태에 빠지지 않도록 **자원 할당 전에 미리 검사**하여 안전한 상태에서만 자원을 할당하는 방식
- 은행가 알고리즘을 참고

