
---

**가) 소스코드 내 해당내용을 자세하고 정확하게 설명할 수 있도록 "제2장 주석및 명명규칙"에 따라 주석을**
**작성하고, 작성 된 주석은 파일별 소스코드의 30%이상으로 한다**.

---

**나) Switch 구문에서 첫번째 Label 전에 코드 구문이 존재하면 안된다.**

### 🚫 잘못된 예제 (위반 사례)

```cpp
void foo(int m)
{
    switch (m)
    {
        n = n + 1; // ❌ 잘못된 위치: 어떤 case label보다 먼저 실행될 수 없음
        case 1:
            --n;
            break;
        default:
            ++n;
            break;
    }
}
```
### ❗ 문제 설명

- `switch` 문 안에서 **어떤** `case` **또는** `default` **label보다 먼저 나오는 코드**는 **절대 실행되지 않습니다**.
- `switch`는 조건에 맞는 label로 **직접 점프**하기 때문에, `n = n + 1;`은 **죽은 코드**(dead code)가 됩니다.
- 일부 컴파일러에서는 경고 또는 오류를 발생시킬 수 있습니다.
### ✅ 올바른 예제 (수정된 코드)

```cpp
void foo(int m)
{
    switch (m)
    {
        case 1:
            --n;
            break;
        default:
            ++n;
            break;
    }
}
```
- `switch` 문 안에는 반드시 `case` **또는** `default` **label이 먼저 나와야** 합니다.
- label 없이 작성된 코드는 **컴파일러가 도달할 수 없는 코드로 간주**합니다.
- 필요한 초기화나 연산이 있다면, `switch` 문 **밖에서** 처리해야 합니다.


---

**다) 함수/변수의 선언 시 type을 명시해야 한다.**

### ❗ 위반 예시 (타입 생략)

```cpp
auto x = 10;         // ❌ 타입이 명시되지 않음
auto foo() {         // ❌ 반환 타입 생략
    return 42;
}
```

- `auto`는 편리하지만, **코드의 명확성을 떨어뜨릴 수 있음**
- 특히 협업이나 코드 리뷰 시 **의도가 불분명**해질 수 있음

### ✅ 올바른 예시 (타입 명시)

```cpp
int x = 10;          // ✅ 타입 명시
int foo() {          // ✅ 반환 타입 명시
    return 42;
}
```

- 타입을 명시하면 **코드의 의미가 명확해지고**, **컴파일러의 타입 추론에 의존하지 않음**
- 유지보수성과 가독성이 향상됨


---

**라) 의미 없는 구문은 사용하지 말아야 한다.(side effect)**

### ❗ 잘못된 예 (위반 사례)

```cpp
void foo(int x)
{
    int n = 0;
    n == x; // ❌ 의미 없는 비교: 결과를 사용하지 않음
}
```

- `n == x`는 **비교 연산**이지만, 그 결과(`true` 또는 `false`)를 **어디에도 사용하지 않음**
- 즉, **프로그램 실행에 아무런 영향도 주지 않는 "죽은 코드(dead code)"**
- 컴파일러에 따라 경고가 발생할 수 있음 (`-Wunused-value` 등)

### ✅ 올바른 예

```cpp
void foo(int x)
{
    int n = 0;
    n = x; // ✅ 의미 있는 대입 연산
}
```

- `n = x`는 실제로 `n`의 값을 변경하므로 **side effect**(부작용)가 존재
- 프로그램의 상태에 영향을 주는 **의미 있는 코드**


---

**마) 함수 선언시 사용된 리턴형과 함수 내에서 사용되는 리턴형은 일치해야 한다.**

### ❗ 잘못된 예 (위반 사례)

```cpp
int f1(int value) {
    return;       // ❌ int를 반환해야 하는데 아무것도 반환하지 않음
}

void f2(int value) {
    return value; // ❌ void 함수는 값을 반환할 수 없음
}

int f1(int value) {
    // ❌ return 문이 없음 → 경고 또는 정의되지 않은 동작
}
```

### ✅ 올바른 예

```cpp
int f1(int value) {
    return value; // ✅ int 반환형과 일치
}

void f2(int value) {
    return;       // ✅ void 함수는 return 없이 종료하거나, return;만 사용 가능
}
```

| 문제점            | 설명                              |
| -------------- | ------------------------------- |
| **정의되지 않은 동작** | 반환형과 실제 반환값이 다르면 런타임 오류 발생 가능   |
| **컴파일러 경고/오류** | 대부분의 컴파일러가 타입 불일치를 경고 또는 오류로 처리 |
| **가독성 저하**     | 함수의 목적과 실제 동작이 불일치하면 유지보수 어려움   |


---

**바) 외부 함수 사용시 이를 명시하고 사용해야 한다.**

### ❗ 잘못된 예 (위반 사례)

```c
int foo(void)
{
    int r;
    r = func(0); // ❌ func가 선언되지 않았음
    return r;
}
```

- `func()`가 외부에서 정의된 함수라면, **선언 없이 사용하는 것은 위험**합니다.
- 컴파일러는 func의 존재를 추측하거나, 기본적으로 `int func()`로 간주할 수 있음 (구식 C 컴파일러 기준)
- **매개변수 타입이 다르거나 반환 타입이 다르면** → 정의되지 않은 동작 발생 가능

### ✅ 올바른 예

```c
extern int func(int value); // ✅ 외부 함수 선언

int foo(void)
{
    int r;
    r = func(0); // 안전하게 호출
    return r;
}
```

- `extern` 선언을 통해 컴파일러는 `func`의 **정확한 시그니처(반환형 + 매개변수 타입)**를 알 수 있음
- 타입 불일치나 인자 개수 오류를 **컴파일 타임에 잡을 수 있음**


---

**사) 전처리에 사용되는 매크로는 사용 전에 반드시 정의되어야 한다.**

### ❗ 잘못된 예 (위반 사례)

```c
#define M1 5

#if (M2 == 5) // ❌ M2는 정의되지 않았음
int y = 0;
#endif
```

- `M2`는 정의되지 않았기 때문에, 전처리기는 **경고 없이 0으로 간주**할 수 있음
- 이로 인해 **예상치 못한 조건 분기**가 발생할 수 있음
- 특히 `#if`, `#elif`에서 정의되지 않은 매크로를 비교하는 건 **위험한 코드**

### ✅ 올바른 예

```c
#ifndef M3
#define M3 0
#endif

#if (M3 == 5)
int z = 0;
#endif
```

- `#ifndef`는 **M3가 정의되지 않았을 경우에만** `#define`을 실행
- 이렇게 하면 **항상 M3가 정의된 상태에서만 비교**가 이루어짐
- 전처리기의 동작이 **예측 가능하고 안전**해짐


---

**아) goto 문을 사용하지 말아야 한다.**
### ❗ 잘못된 예 (위반 사례)

```c
short test_1404(void)
{
    if (abc > 10)
    {
        goto mylabel; // ❌ 흐름이 갑자기 점프함
    }
    abc++;
mylabel:
    ...
}
```

- `goto`는 코드 흐름을 **임의의 위치로 점프**시킵니다.
- 이로 인해 **코드의 흐름이 예측하기 어렵고**, **디버깅이 매우 힘들어집니다**.
- 특히 여러 개의 `goto`가 얽히면 **스파게티 코드**가 되기 쉽습니다.

### ✅ 올바른 예 (대체 구조 사용)

```c
short test_1404(void)
{
    while (abc < 10)
    {
        abc++;
    }
    ...
}
```

- `while`, `for`, `if`, `break`, `continue` 같은 **구조적 제어문**을 사용하면
- 코드의 흐름이 **위에서 아래로 자연스럽게 이어지며**, **가독성과 유지보수성이 향상**됩니다.


---

**자) 하나의 함수는 하나의 Exit Point를 가져야 한다.**
### ❗ 잘못된 예 (위반 사례)

```c
int S16test_1407(void)
{
    if (s16a > 0)
    {
        return 0;  // ❌ 첫 번째 exit point
    }
    else
    {
        return 1;  // ❌ 두 번째 exit point
    }
}
```

- `return`이 여러 개 존재하면 **함수의 흐름을 추적하기 어려워지고**, **디버깅이나 로깅, 리소스 해제 등의 일관된 처리가 어려워질 수 있습니다.**

### ✅ 올바른 예 (단일 Exit Point)

```c
int S16test_1407(void)
{
    int temp;
    if (s16a > 0)
    {
        temp = 0;
    }
    else
    {
        temp = 1;
    }
    return temp; // ✅ 하나의 exit point만 존재
}
```

- 함수의 **마지막 한 줄에서만 return**을 사용함으로써,
- **모든 경로가 하나의 지점으로 수렴**되며, 유지보수와 분석이 쉬워집니다.


---

**차) switch ~ case 문은 default 문이 포함되어야 한다.**
### ❗ 잘못된 예 (위반 사례)

```c
switch (s16a)
{
case 0:
    x = 2;
    break;
case 1:
    x = 1;
    break;
}  /* default 없음 */
```

### ✅ 올바른 예 (단일 Exit Point)

```c
switch (s16a)
{
case 0:
    x = 2;
    break;
case 1:
    x = 1;
    break;
default:
    x = 0;
    break;
}
```
- switch 문에 default를 포함하면 예측하지 못한 값에 대한 방어 로직을 추가할 수 있어 코드를 더 안전하게 만듭니다.
- case만 나열된 구조보다 default가 있으면 의도가 명확해져 가독성이 향상됩니다.

### ❗ 잘못된 예 (위반 사례)

```c
r = p; p++; // ❌ 두 개의 명령문이 한 줄에 있음
```

- 여러 명령문이 한 줄에 있으면 **코드가 복잡하게 보이고**, **실수하거나 놓치기 쉬운 버그**가 생길 수 있습니다.
- 디버깅 시에도 **한 줄에 여러 동작이 섞여 있으면 추적이 어려워집니다.**

### ✅ 올바른 예

```c
r = p;
p++;
```

- 각 명령문이 **명확하게 분리**되어 있어 가독성이 좋고,
- 코드 리뷰나 디버깅 시에도 **한 줄씩 의미를 파악하기 쉬움**


---

**카) 한 줄에 하나의 명령문을 사용한다.**

### ❗ 잘못된 예 (위반 사례)

```c
r = p; p++; // ❌ 두 개의 명령문이 한 줄에 있음
```

- 여러 명령문이 한 줄에 있으면 **코드가 복잡하게 보이고**, **실수하거나 놓치기 쉬운 버그**가 생길 수 있습니다.
- 디버깅 시에도 **한 줄에 여러 동작이 섞여 있으면 추적이 어려워집니다.**

### ✅ 올바른 예

```c
r = p;
p++;
```

- 각 명령문이 **명확하게 분리**되어 있어 가독성이 좋고,
- 코드 리뷰나 디버깅 시에도 **한 줄씩 의미를 파악하기 쉬움**


---

**타) if - else if 문은 else 문도 반드시 포함 시킨다.**

### ❗ 잘못된 예 (위반 사례)

```c
if (s16a == 2)
{
    r = 3;
}
else if (s16a == 3) // ❌ else 없음
{
    r = 2;
}
```

- `s16a`가 2도 아니고 3도 아닐 경우, **아무 동작도 하지 않음**
- 이로 인해 **예외 상황이 처리되지 않고**, **버그가 발생할 가능성**이 있음

### ✅ 올바른 예

```c
if (s16a == 2)
{
    r = 3;
}
else if (s16a == 3)
{
    r = 2;
}
else
{
    r = 1; // ✅ 예외 상황 처리
}
```

- `else` 블록을 통해 **모든 경우에 대한 처리가 보장**됨  
- 예외 상황에 대한 **명시적 방어 코드**가 포함되어 있어 안정성이 높아짐


---