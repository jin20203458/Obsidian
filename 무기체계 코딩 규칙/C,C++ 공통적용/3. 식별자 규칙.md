

---

**가) external과 internal linkage의 특성을 동시에 가질 수 없다.**

### ❗ 잘못된 예 (위반 사례)

```c
extern int foo(int value);
extern int number;
/* ... */
static int number;       // ❌ 외부에서 참조하겠다고 해놓고 내부 전용으로 선언
static int foo(int value); // ❌ 외부 함수라고 해놓고 내부 전용으로 선언
```

- `extern`은 **external linkage**: 다른 파일에서도 참조 가능
- `static`은 **internal linkage**: 해당 파일 내부에서만 사용 가능
- 같은 식별자에 대해 두 가지를 동시에 선언하면 **모순된 의미**가 되어 **정의되지 않은 동작**이 발생할 수 있음

### ✅ 올바른 예

```c
extern int foo(int value);
extern int number;
/* ... */
extern int number;
extern int foo(int value);
```

- `extern`만 사용하여 **외부에서 정의된 함수/변수**를 참조
- `static`과 혼용하지 않음 → **링크 속성이 일관됨**

## 🧠 왜 문제가 될까?

|키워드|의미|링크 속성|
|---|---|---|
|`extern`|외부 정의를 참조|external linkage|
|`static`|파일 내부에서만 사용|internal linkage|

- 동일한 이름에 대해 `extern`과 `static`을 혼용하면 컴파일러가 **링커에 어떤 심볼을 연결해야 할지 모르게 됨**
- C 표준(C99, C11)에서도 **이런 혼용은 금지**되어 있음


---

**나) external linkage scope에서 선언된 함수나 Object의 이름은 유일해야 한다.**
### ❗ 잘못된 예 (위반 사례)

```c
// TU1.c
int press;
void foo(void) { }

// TU2.c
float press;       // ❌ press가 중복 정의됨
void foo(int) { }  // ❌ foo가 다른 시그니처로 중복 정의됨
```

- `press`와 `foo`는 **external linkage**를 가지므로, **링커는 전역에서 하나의 정의만 허용**합니다.
- 두 개의 번역 단위(TU1.c, TU2.c)에서 **동일한 이름을 가진 전역 심볼이 정의되면 링커 오류** 발생

### ✅ 올바른 예

```c
// TU1.c
int press;
void foo(void) { }

// TU2.c
float local_press;       // ✅ 이름 다름
void foo_tu2(int) { }    // ✅ 이름 다름
```

- 이름을 다르게 하여 **심볼 충돌을 방지**
- 또는 `static`을 사용하여 **internal linkage로 제한**할 수도 있음


---

**다) external linkage scope에서 정의된 함수나 Object의 데이터형은 선언 시 정의와 동일해야 한다.**

- 외부에서 참조하는 함수나 변수는 **정의된 타입과 선언된 타입이 반드시 일치해야 한다**

