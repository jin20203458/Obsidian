

---

**가) 선언된 데이터 형으로 표현할 수 있는 숫자의 영역을 초과하는 값을 할당하지 말아야 한다.**

### ❌ 잘못된 예 (Overflow 발생)

```c
void foo(short n)
{
    short x;
    x = 10000 * 4;  // ❌ 40000은 short의 표현 범위(32767)를 초과
}
```

- `short`는 일반적으로 **-32,768 ~ 32,767** 범위
- `10000 * 4 = 40000`은 **overflow** 발생 → **예상치 못한 값 저장**

### ✅ 바른 예 (적절한 타입 사용)

```c
void foo(long n)
{
    long x;
    x = 10000 * 4;  // ✅ long은 40000을 충분히 표현 가능
}
```

- 타입을 `long`으로 바꿔서 **값 손실 없이 안전하게 저장**


---

**나) 가변인수를 받는 함수의 Conversion 지시자와 Argument의 type은 동일해야한다.**
- **가변 인수 함수(예: printf)에서 포맷 지시자와 인자의 타입이 반드시 일치해야 한다**

### ❌ 잘못된 예 (타입 불일치)

```c
#include <stdio.h>

extern void foo(int n, unsigned char *s)
{
    printf("The total is %s", n);  // ❌ %s는 문자열 포인터 기대, int 전달됨
}
```

### 문제점

- `%s`는 `char*` 또는 `unsigned char*` 타입을 기대

- `int` 타입인 `n`을 `%s`에 전달하면:
    
    - **메모리 주소로 해석**되어 쓰레기 값 출력
    - **세그멘테이션 오류(segfault)** 발생 가능
    - **표준에 정의되지 않은 동작(undefined behavior)**

### ✅ 바른 예 (타입 일치)

```c
#include <stdio.h>

extern void foo(int n, unsigned char *s)
{
    printf("The total is %d", n);  // ✅ %d는 int 타입과 정확히 일치
}
```

- `%d`는 `int` 타입을 정확히 출력
- 포맷 문자열과 인자 타입이 일치하므로 **안전하고 명확**


---
