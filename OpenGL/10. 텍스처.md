OpenGL은 3차원 그래픽 라이브러리이지만 2차원의 그래픽을 관리하는 기능도 제공한다. 텍스처 맵핑을 위해 2차원 비트맵을 처리하는 기능이 필요하며 또한 3차원 그래픽이라도 투영 후에는 2차원이 되므로 이 또한 다룰 수 있어야 하기 때문이다. 물론 전문적인 2차원 그래픽 라이브러리에 비할 바는 아니다.

비트맵은 미리 만들어진 이미지를 의미하며 다양한 크기와 색상을 가질 수 있다. 그러나 OpenGL에서는 흑백 이미지만을 비트맵이라고 칭하며 컬러 이미지는 픽셀맵(Pixelmap)이라는 별도의 용어를 사용한다. bit가 용어가 원래 0과 1만을 의미하는 흑백적인 뜻이기 때문이라고 한다. 사실 디지털 이미지라는 정의가 가장 정확한데 어쨌든 OpenGL은 컬러 이미지와 흑백 이미지를 구분한다고 알아 두자.

비트맵은 보통 대용량의 래스터 데이터로 구성되므로 파일 형태로 저장되는 것이 일반적이다. 그러나 안타깝게도 OpenGL은 파일 입출력 기능을 제공하지 않으므로 파일이나 리소스로부터 비트맵을 생성하기 어렵다. 간단한 이미지라면 메모리에서 래스터 데이터를 직접 정의하여 만들어 써야 한다. 모눈 종이에 다음과 같이 이미지를 디자인해 보자.

![[Pasted image 20240615204309.png]]

비트맵을 만드는 아주 원시적인 방법인데 각 칸의 흰색은 이진수 0에 대응시키고 검정색은 1에 대응시킨다. 이 수를 나열하면 2진수가 나오는데 자리 수가 너무 많으므로 보통 16진수로 압축한다. 이렇게 만든 16진수를 배열에 순서대로 기록하면 비트맵이 된다. OpenGL의 비트맵은 아래에서 위로 정의되므로 제일 아래줄부터 배열에 기록한다.

비트맵의 래스터 데이터는 처리의 효율성을 위해 4바이트 단위로 정렬된다. 왜냐하면 대부분의 컴퓨터는 32비트이고 한번에 4바이트씩 읽고 쓰는 속도가 가장 빠르기 때문이다. 한 행이 4의 배수가 안되더라도 뒷 부분에 더미를 추가해서라도 4의 배수로 맞추는 것이 유리하다. 그러나 위 이미지는 한 행이 2바이트 밖에 안되어 더미를 넣으면 무려 2배나 커진다. 정렬 단위를 바꾸고 싶다면 다음 함수로 비트맵의 저장 방식을 변경해야 한다.

void glPixelStore[f, i] (GLenum pname, GLfloat param);

이 함수로 바이트 순서(GL_PACK_SWAP_BYTES)나 바이트 정렬(GL_PACK_ALIGNMENT) 등의 옵션을 지정한다. 메모리에서 비트맵을 읽을 때의 정렬은 GL_UNPACK_ALIGNMENT 옵션으로 지정하며 이 값의 디폴트가 4이므로 4바이트 정렬된다. 2나 1로 바꾸면 더 작은 단위로 정렬할 수 있되 단, 값을 일일이 잘라서 읽어야 하므로 속도에는 불리하다. 비트맵의 출력 위치는 다음 함수로 지정한다.

void glRasterPos[2,3,4]  [s,i,f,d]  [v] (x, y,z,w);

좌표를 지정하는 함수이므로 glVertex 함수와 형식이 거의 동일하다. 이 함수가 지정한 좌표가 현재 위치가 되며 이 위치에서부터 비트맵이 출력되고 비트맵 출력 후 현재 위치는 자동으로 다음 위치로 갱신된다. 마치 텍스트 모드에서 다음 문자가 출력될 위치를 지정하는 커서의 개념과 유사하다.

이 함수가 지정한 좌표는 변환의 영향을 받는다. 만약 변환에 상관없이 윈도우의 특정 좌표에 출력하려면 glWindowPos 함수를 대신 사용한다. 그러나 이 함수는 OpenGL 1.4 이후부터만 지원되므로 윈도우즈의 기본 구현에서는 당장 사용할 수 없다. 비트맵을 출력할 때는 다음 함수를 호출한다.

void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove,  GLfloat ymove, const GLubyte * bitmap);

제일 마지막 인수인 bitmap이 비트맵의 모양을 정의하는 래스터 데이터 배열이다. width, height는 비트맵의 폭과 높이를 픽셀 단위로 알려 주는데 일차원 배열의 래스터만으로는 비트맵의 모양을 알 수 없기 때문에 크기 정보를 별도로 제공해야 한다. 위 비트맵은 16 * 16 크기이므로 폭과 높이가 모두 16이다.

xorig, yorig 인수는 비트맵의 어느 부분이 현재 위치에 출력될 것인지 원점을 지정한다. 보통은 좌하단인 (0,0)을 지정하여 비트맵의 아래쪽이 현재 위치에 출력되지만 모양이 특이한 비트맵은 원점을 변경할 수도 있다. xmove, ymove는 비트맵을 그린 후에 이동할 양을 거리를 지정한다. 마치 문자를 출력한 후 커서를 옮기듯이 현재 위치를 적당량 띄운다.

비트맵은 단 두 가지 색으로만 구성된 그림이지만 그렇다고 해서 꼭 흑백으로만 출력해야 하는 것은 아니다. glColor 함수로 색상을 지정하면 비트맵의 1에 대응되는 부분에 이 색상이 출력된다. 그래서 단색 비트맵이지만 노란색이나 빨간색으로도 출력할 수 있다. 다음 예제는 앞에서 디자인한 16 * 16 크기의 비트맵을 출력한다.

