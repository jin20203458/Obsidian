지금까지의 실습에서는 디폴트로 주어진 좌표 공간을 그냥 사용했다. -1 ~ 1 사이의 좁은 공간에 물체를 배치했으면 위치도 항상 중앙의 원점이었다. 이제 좌표 공간과 물체에 변화를 주어 보자. 지금까지는 입체 확인을 위해 회전 변환만 사용해 보았는데 이 절에서 여러 가지 변환을 실습해 볼 것이다.

3차원 공간에 배치된 물체는 이동, 확대, 회전 등 여러 가지로 변화를 줄 수 있으며 보는 각도에 따라 모양이 달라지기도 한다. 좌표 공간 자체도 범위와 증감 방향에 대해 원하는대로 지정할 수 있다. 또 3차원 공간의 장면도 결국은 모니터나 지면에 출력해야 하므로 2차원으로 바꿔야 한다. 이 각각의 과정에서 복잡한 변환이 발생한다. 전체적인 변환 과정은 다음과 같다.

![[Pasted image 20240612001520.png]]

void glMatrixMode(GLenum mode);

인수로 대상 행렬을 지정하며 이를 행렬 모드라고 한다. 이 함수로 지정한 행렬은 이후의 모든 행렬 연산의 대상이 된다. 물론 다른 행렬을 조작하고 싶을 때는 언제든지 행렬 모드를 바꿀 수 있다. 다음과 같은 행렬 모드가 있는데 주로 모델뷰 행렬이나 투영 행렬이 변환 대상이다. 디폴트는 모델뷰 행렬이다.

|열거형|설명|
|---|---|
|GL_MODELVIEW|모델 뷰 변환 행렬. 이 값이 디폴트이다.|
|GL_PROJECTION|투영 행렬|
|GL_TEXTURE|텍스처 행렬|
|GL_COLOR|색상 행렬. 단 이 기능은 ARB_imaging 확장 기능이 지원되어야 한다.|
현재 행렬이 무엇인지를 알아내려면 glGet 함수로 GL_MATRIX_MODE를 전달한다. 현재 행렬을 지정한 후 다양한 행렬 조작을 할 수 있다. 앞으로 여러 가지 변환 함수들을 배우겠지만 일단 대표적으로 다음 함수 하나에 대해 알아 보자.

void glLoadIdentity(void);

이 함수는 현재 행렬을 단위 행렬로 만든다. 

단위 행렬은 우하향 대각선 방향만 1이고 나머지 요소는 모두 0인 행렬로서 임의의 행렬을 곱해도 원래 행렬이 계산되는 특수한 행렬이다. 

곰셉의 1, 덧셈의 0과 같은 항등원으로서 연산을 해도 처음값이 유지된다. 현재 행렬을 단위 행렬로 만든다는 것은 **행렬을 리셋한다는 뜻이며 이는 곧 어떠한 변환도 하지 않는다는 뜻이다.** 지금까지 입체 확인을 위해 회전 기능을 사용했던 모든 예제를 보면 다음 두 행의 코드가 있다.

glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

이 코드는 모델뷰 행렬을 리셋한다. DoDisplay를 이전에 실행했을 때 적용했던 회전값을 무시하고 다시 설정하기 위해 리셋을 해야 한다. 이 리셋 코드가 없으면 회전이 계속 누적 적용되어 원하는 대로 회전되지 않는다. 그림을 그리기 전에 화면을 지우는 것과 마찬가지로 **행렬을 사용하기 전에 리셋을 먼저 해야 한다.**

#### 관측 변환

**관측(Viewing)이란 3차원 공간의 장면을 바라본다는 뜻이다.**
관측 변환은 장면을 바라보는 사용자의 위치나 시점, 각도를 변경하는 변환이다. 같은 장면이라도 어디서 어떤 각도로 바라 보는가에 따라 모양이 완전히 달라진다. 마치 장면을 촬영하는 카메라를 이리 저리 옮기는 기법과 유사해서 카메라 변환이라고도 한다. 관측 지점은 다음 함수로 지정한다.

void gluLookAt(
    GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ,
    GLdouble centerX, GLdouble centerY, GLdouble centerZ,
    GLdouble upX, GLdouble upY, GLdouble upZ
);

보다시피 이 함수는 gl의 함수가 아니라 glu의 유틸리티 함수이다. 왜냐하면 이 함수가 아니어도 동일한 효과를 낼 수 있는 방법이 있기 때문이다. 인수가 굉장히 많은 것처럼 보이는데 세 가지 관점에 대해 x, y, z 각 세쌍씩이므로 총 9개의 인수가 필요하다.

eye 좌표는 시선의 좌표 즉, 관찰자의 위치를 나타내는 좌표이다. center는 관찰자가 바라보고 있는 좌표이다. up은 위쪽을 가리키는 업 벡터를 나타낸다. 카메라로 장면을 촬영하고 있다면 카메라가 있는 곳이 eye 좌표이고 카메라가 초점으로 정한 부분이 center 좌표이며 카메라의 각도가 up 벡터이다. 규칙상 up 벡터는 시선과 평행해서는 안된다.

관측지점을 옮기는것은 곧 물체가 멀어진다는 것이다. (나로부터)
내가 멀어지나 물체가 멀어지나 ...

### 모델링 변환

모델링(Modeling) 변환은 3차원 공간에 배치된 물체를 변형한다. 이동, 확대/축소, 회전 등 여러 가지 변환이 있으며 두 가지 이상의 변환을 동시에 적용하기도 한다. 양이 좀 많지만 특별히 어렵지는 않으므로 순서대로 구경만 해 보면 된다.

```
#include <windows.h>
#include <gl/glut.h>

void DoDisplay();
void DoMenu(int value);
int Action;

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutCreateWindow("OpenGL");
    glutDisplayFunc(DoDisplay);
    glutCreateMenu(DoMenu);
    glutAddMenuEntry("변환 없음", 0);
    glutAddMenuEntry("이동", 1);
    glutAddMenuEntry("엉뚱한 위치에 나타나는 이동", 2);
    glutAddMenuEntry("단위 행렬로 리셋", 3);
    glutAddMenuEntry("스택에 저장 및 복구", 4);
    glutAddMenuEntry("확대", 5);
    glutAddMenuEntry("회전", 6);
    glutAddMenuEntry("확대 후 이동", 7);
    glutAddMenuEntry("이동 후 확대", 8);
    glutAddMenuEntry("원점 기준 회전", 9);
    glutAddMenuEntry("제자리 회전", 10);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
    return 0;
}
void DoMenu(int value)
{
    if (value < 100) {
        Action = value;
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glColor3f(1, 1, 1);
        glutPostRedisplay();
        return;
    }
}
void DoDisplay()
{
    // 변환 없음
    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);
    glFlush();

}
```
처음 중앙에 주전자가 있다.
![[Pasted image 20240612003515.png]]
오른쪽으로 0.6만큼 이동시킨 후 똑같은 주전자를 하나 더 그렸다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);
    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612003947.png]]
이번에는 오른쪽뿐만 아니라 가운데 주전자의 위쪽에도 하나를 더 그려 보자. y 축으로 0.5만큼 이동한 곳에 하나 더 그리면 될 것 같다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);

    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);

    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612004144.png]]
? 우리 목적은 x축 0.6간 1개 y축 0.6 간 1개 였는데 대각선에 1개가 그려져있다.

이렇게 되는 이유는 변환이 누적적으로 적용되기 때문이다. 변환 함수는 현재 행렬에 변환 공식을 써 넣으며 현재 행렬은 이후의 모든 출력에 영향을 미친다. 행렬을 리셋하거나 특별히 다른 값으로 바꾸지 않는 한 현재 값이 계속 유지되고 매 호출시마다 행렬에 변환이 가해진다. 먼저 오른쪽으로 0.5 이동했고 다시 위로 0.5 이동했으므로 세번째 주전자는 오른쪽 위로 이동하는 것이다.

이를 해결하려면 행렬을 다시그릴때 마다 초기화 해야한다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);

    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);

    glLoadIdentity(); // 초기화 구문
    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612004327.png]]
원하는 결과가 나왔다.

단위 행렬로 리셋하는 대신에 이전의 행렬을 스택에 저장하는 방법도 사용할 수 있다. 행렬을 스택에 저장하거나 복구할 때는 다음 함수를 호출한다.

void glPushMatrix(void);
void glPopMatrix(void);

행렬은 단순한 하나의 값이 아니라 스택에 여러 개가 저장되며 그 중 스택의 제일 위에 있는 행렬이 현재 행렬이다. 스택의 깊이는 행렬의 종류에 따라 다른데 모델뷰 행렬은 32개까지 저장할 수 있으며 투영 행렬은 2개만 저장할 수 있다. 다음과 같이 해도 결과는 같다.
```
void DoDisplay()
{
    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glutWireTeapot(0.2);

    glPushMatrix();
    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);
    glPopMatrix();

    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glPopMatrix();

    glFlush();
}
```
그리기 전의 행렬을 일단 저장한다. 원점에 주전자를 그린 후 오른쪽으로 이동하기 전에 한번 더 저장한다. 이 상태에서 오른쪽으로 이동한 곳에 주전자를 그리고 다시 복구한다. 원점으로 제깍 돌아올 것이다. 이 상태에서 위로 이동한 후 그리면 원점 바로 위가 된다. 모든 그리기가 끝난 후 다시 복구하면 DoDisplay를 호출하기 전의 상태로 돌아간다.

행렬을 리셋하는 방법은 무조건 단위 행렬로 돌아가는데 비해 스택을 사용하는 방법은 이전 상태를 그대로 저장했다가 복구한다는 면에서 더 범용적이다. DoDisplay 안에서 행렬을 어떻게 조작하든간에 리턴할 때 원래대로 복구하므로 외부에서 가한 변환이 유지되며 그리기를 여러 번 하더라도 변환이 누적되지 않는다.

여러 곳에서 공유되는 전역 변수나 상태는 원칙적으로 바꾼 놈이 원래대로 돌려 놓는 것이 옳다. 행렬도 상태 머신에 저장되는 전역 값이므로 행렬을 바꾸는 측에서 원래값을 복원하는 것이 좋다. 이후 변환을 수행하는 코드에서는 원칙대로 행렬을 저장한 후 리턴하기 전에 복구할 것이다. 다음 함수는 물체를 확대한다.
