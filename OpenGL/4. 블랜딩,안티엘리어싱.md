
화면에 그려진 그림은 색상 버퍼라는 메모리에 저장된다. 그림이 이미 그려져 있는 상태에서 같은 위치에 다른 그림을 그리면 새 그림을 메모리에 기록하므로 이전에 그려져 있던 그림은 덮여서 지워진다. 이 당연한 현상도 블랜딩 모드를 변경하면 달라질 수 있다. 블랜딩은 색상 버퍼에 이미 기록되어 있는 값과 새로 그려지는 값의 논리 연산 방법을 지정한다.

다른 프로그래밍 언어에서 ROP 모드(Raster Operation)라고 흔히 부르는 연산이되 그보다는 훨씬 더 상세하다. 디폴트 모드가 단순한 복사이므로 이전 그림이 지워지지만 다른 모드를 사용하면 두 값을 논리적으로 연산한 결과를 써 넣음으로써 특이한 효과를 낼 수 있다. 블랜딩 기능을 사용하라면 다음 명령으로 이 기능을 켜야 한다.

glEnable(GL_BLEND);

블랜딩은 색상 버퍼에 이미 기록되어 있는 값 D와 새로 기록되는 값 S와의 연산을 정의한다. 연산 방법은 다음 두 함수로 지정한다.

void glBlendFunc(GLenum sfactor, GLenum dfactor);
void glBlendEquation(GLenum mode);

sfactor와 dfactor는 S색상과 D색상에 각각 적용할 연산식을 정의하며 mode는 두 연산 결과를 합칠 방법을 정의한다. 모드에 따른 연산식은 다음과 같다. 디폴트는 두 연산식을 더하는 GL_FUNC_ADD이다.

|모드|연산식|
|---|---|
|GL_FUNC_ADD|S * SF + D * DF (디폴트)|
|GL_FUNC_SUBTRACT|S * SF - D * DF|
|GL_FUNC_REVERSE_SUBTRACT|D * DF - S * SF|
|GL_MIN|S * SF 와 D * DF 중 작은 값|
|GL_MAX|S * SF 와 D * DF 중 큰 값|
S와 D에 적용되는 연산식의 종류는 다음과 같다. 이해를 돕기 위해 잘 사용되지 않는 일부 항을 생략했는데 더 정확한 식은 레퍼런스를 보기 바란다.

|모드|색상(FR, FG, FB, FA)|
|---|---|
|GL_ZERO|(0, 0, 0, 0)|
|GL_ONE|(1, 1, 1, 1)|
|GL_SRC_COLOR|(RS, GS, BS, AS)|
|GL_ONE_MINUS_SRC_COLOR|(1 - RS, 1 - GS, 1 - BS, 1 - AS)|
|GL_DST_COLOR|(RD, GD, BD, AD)|
|GL_ONE_MINUS_DST_COLOR|(1 - RD, 1 - GD, 1 - BD, 1 - AD)|
|GL_SRC_ALPHA|(AS, AS, AS, AS)|
|GL_ONE_MINUS_SRC_ALPHA|(1 - AS, 1 - AS, 1 - AS, 1 - AS)|
|GL_DST_ALPHA|(AD, AD, AD, AD)|
|GL_ONE_MINUS_DST_ALPHA|(1 - AD, 1 - AD, 1 - AD, 1 - AD)|
|GL_CONSTANT_COLOR|(RC, GC, BC, AC)|
|GL_ONE_MINUS_CONSTANT_COLOR|(1 - RC, 1 - GC, 1 - BC, 1 - AC)|
|GL_CONSTANT_ALPHA|(AC, AC, AC, AC)|
|GL_ONE_MINUS_CONSTANT_ALPHA|(1 - AC, 1 - AC, 1 - AC, 1 - AC)|
|GL_SRC_ALPHA_SATURATE|(i, i, i, 1)|

