
### 1. 점

모든 디지털 그래픽의 기본은 점(Pixel)이다. 선이나 면도 모두 점의 집합으로 표현할 수 있다. 그러나 3차원 그래픽의 가장 원자적인 요소는 정점(Vertex)이다. 정점은 색상이나 크기에 대한 정보는 없고 오로지 위치만을 가진다는 면에서 점과는 다르다. 정점은 다음 두 함수 블록 사이에서 정의한다.

void glBegin(GLenum mode);
void glEnd(void);

glBegin ~ glEnd 블록 사이에 다양한 함수들이 호출되는데 주로 정점을 배치하거나 속성을 바꾸는 명령들이다. 정점은 다음 함수로 지정한다. 앞에서 설명한대로 좌표 지정 인수를 4개까지 취할 수 있고 인수의 타입도 다양하다. 여기서는 평면 도형을 그리는 실습을 먼저 하므로 좌표는 x, y 두 개만 지정한다.

glVertex[(2,3,4) (s,i,f,d) (v) (x,y,z,w)] <- 정점을 지정
glColor[(3,4)(b,s,i,f,d,ub,us,ui)(v)] (red, green, blue, alpha) <- 정점의 색을 지정

블록내의 정점들로 무엇을 어떻게 그릴 것인가는 glBegin으로 전달되는 모드값에 의해 결정된다. 다음과 같은 모드가 제공되며 모드에 따라 정점을 연결하는 방식이 달라진다. 이 모드들을 완벽하게 이해하고 자유 자재로 쓸 수 있어야 한다.

| 모드                | 설명               |
| ----------------- | ---------------- |
| GL_POINTS         | 독립적인 점           |
| GL_LINE_STRIP     | 연결된 선분           |
| GL_LINE_LOOP      | 시작점과 끝점을 이은 선분   |
| GL_LINES          | 두 개의 정점들을 이은 선분  |
| GL_TRIANGLES      | 세 개씩 연결한 삼각형     |
| GL_TRIANGLE_STRIP | 연결된 삼각형          |
| GL_TRIANGLE_FAN   | 중심을 공유하는 삼각형     |
| GL_QUADS          | 정점 4개씩을 연결하여 사각형 |
| GL_QUAD_STRIP     | 연결된 사각형          |
| GL_POLYGON        | 연결된 볼록 다각형       |
GL_POINTS    ![[Pasted image 20240606204850.png]]
void glPointSize(GLfloat size); 를 통해 정점 크기를 변화시킬수 있다.

### 2. 선

정점들을 연결하면 선분이 된다. 
void glLineWidth(GLfloat width); <- 선의 굵기를 조정하는 함수

GL_LINE_STRIP  ![[Pasted image 20240606204955.png]]

GL_LINE_LOOP  ![[Pasted image 20240606205037.png]]

GL_LINES            ![[Pasted image 20240606205130.png]]

실선이 아닌 다른 모양의 선을 그리려면 스티플(Stipple:점묘법) 기능을 켜야 한다. 특정 기능을 사용할 때는 glEnable 함수로 사용할 기능의 이름을 전달한다. 스티플 기능은 다음 호출문에 의해 활성화된다. **대부분의 기능은 디폴트로 꺼져 있으므로 사용하려면 반드시 켜야 한다.**

glEnable(GL_LINE_STIPPLE); : 사용하지 않는다면 glDisable 로 언제든 취소가 가능!

선의 모양은 다음함수로 지정한다.
void glLineStipple(GLint factor, GLushort pattern);

pattern은 이진수로 표현한 선의 모양이다. 하위 비트부터 선의 앞쪽 부분의 점 모양을 지정한다. 대응되는 비트가 1인 자리는 점이 찍히고 0인 부분은 찍히지 않는다. factor 인수는 비트 하나가 점 몇 개에 대응될 것인가를 지정한다. 이 값이 1이면 비트 하나가 점 하나에 대응되며 2이면 비트당 2개의 점이 그려져 좀 더 긴 모양을 만들 수 있다. 다음 예제는 점섬, 쇄선 등을 출력한다.

```
void 그리기()
{
    GLushort arPat[] = { 0xaaaa,0xaaaa,0xaaaa,0xaaaa,0x33ff,0x33ff,0x33ff,0x57ff,0x57ff };
    GLint arFac[] = { 1,     2,     3,     4,     1,     2,     3,     1,     2 };

    glClear(GL_COLOR_BUFFER_BIT);
    glEnable(GL_LINE_STIPPLE);

    GLfloat y;
    GLint idx = 0;

    for (y = 0.8; y > -0.8; y -= 0.2) {

        glLineStipple(arFac[idx], arPat[idx]);
        glBegin(GL_LINES);
        glVertex2f(-0.8, y);
        glVertex2f(0.8, y);
        glEnd();
        idx++;
    }
    glFlush();
}
```
