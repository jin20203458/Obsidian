입체 도형은 아주 많은 정점들과 관련 정보들로 구성된다. 그럴싸한 입체 도형 하나를 만들려 glVertex 함수를 수천, 수만번을 호출해야 하고 각 정점마다 색상이나 법선 정보도 필요하다. 정보가 많은 것은 어쩔 수 없는 일이지만 각 정보마다 함수를 일일이 호출하는 것은 낭비가 너무 심하다. 알다시피 함수 호출은 실행 파일 크기면에서나 속도면에서나 비용이 꽤 비싼 동작이다.

각 정점마다 달라지는 것은 좌표일 뿐이므로 이 좌표들을 하나의 배열에 모아 둔 후 루프를 돌리면서 배열 요소를 하나씩 전달하는 것이 구조적으로 훨씬 더 나은 방법이다. 프로그래밍의 기본을 아는 사람이라면 반복이 과도해질 때 당연히 이 방법을 떠올릴 것이다. OpenGL도 배열로 정점의 집합을 정의하는 방법을 공식적으로 지원한다. 먼저 다음 함수를 호출하여 배열을 사용하도록 설정한다.

void glEnableClientState(GLenum cap);
void glEnableClientState(GLenum cap);

**배열을 사용하는 것은 OpenGL 서버인 그래픽 카드의 설정과는 상관이 없고 그래픽을 그리는 클라이언트인 CPU와 상관이 있으므로 glEnable 함수를 사용하지 않는다.** 어떻게 그릴 것인가의 문제가 아니고 어떻게 정보를 전달할 것인가의 문제이므로 배열 사용 여부는 클라이언트의 설정일 뿐이다. 그래서 glEnable 함수 대신 glEnableClientState 함수를 사용한다. 인수로 어떤 배열을 사용할 것인가를 전달한다.

GL_COLOR_ARRAY
GL_EDGE_FLAG_ARRAY
GL_FOG_COORD_ARRAY
GL_INDEX_ARRAY
GL_NORMAL_ARRAY
GL_SECONDARY_COLOR_ARRAY
GL_TEXTURE_COORD_ARRAY
GL_VERTEX_ARRAY

정점뿐만 아니라 각 정점의 색상이나 법선 정보, 텍스처 좌표 등도 배열로 정의 가능하다. 입체 도형을 구성하기 위한 모든 정보들을 하나의 배열에 집약할 수 있다. 배열은 동일 타입 변수의 집합일 뿐이므로 일반적인 C 구문으로 작성한다. 정점 배열의 경우 GLfloat 타입의 일차원 배열을 선언하고 배열을 구성하는 x, y나 x,y,z 좌표를 죽 나열하면 된다.

ex)  GLfloat vert[] = { x1, y1, z1, x2, y2, z2, .... };

배열 요소는 필요한만큼 얼마든지 나열할 수 있다. 미리 정의해 놓은 이진 데이터를 파일이나 네트워크로 읽어들일 수도 있고 필요할 경우 일부를 약간 변형하는 것도 가능하다. 다음 함수는이 배열의 위치와 구조를 알려 준다. 

void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);

size : 요소의 개수 (x,y 로 구성된 좌표이면2, xyz이면 3),
type : 요소의 타입 (GL_INT, GL_FLOAT..등),
stride : 배열 요소간의 간격,
pointer : 배열의 실제 주소

색배열 
( rgb, rgba 등으로 구성될 수 있으므로 size 인수가 있다. 
단, size의 가능한 값은 3 또는 4뿐이라는 점에서 정점 배열과는 다르다.)
void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);

법선 배열 
(무조건 x,y,z 세개가 1쌍이기에 size 는 따로 없다.)
void glNormalPointer(GLenum type, GLsizei stride, const GLvoid * pointer);

void glArrayElement(GLint i);
이 함수는 배열에서 i 번째 정점 좌표를 꺼내 해당 정보를 서버로 전달한다. size와 type 정보를 바탕으로 한번에 몇 개씩 꺼낼 것인가를 결정할 수 있다. 정점 배열이라면 glVertex 함수를 호출하고 색상 배열이라면 glColor를 호출할 것이다. 배열로부터 정점을 정의할 경우에는 glBegin과 glEnd 블록에서 이 함수를 호출하면 된다.


