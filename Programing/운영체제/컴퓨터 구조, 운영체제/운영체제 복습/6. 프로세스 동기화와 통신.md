
프로세스 동기화란?

멀티프로세싱 환경에서 여러 프로세스가 동시에 실행될 때, 공유 자원에 대한 접근을 조정하고 서로 간의 실행 순서를 제어하는 것

중점
- 실행 순서 제어
- 상호 배제



프로세스 동기화가 필요한 이유
1. 무결성 유지
2. 상호 배제
3. 교착 상태 관리
4. 효율적인 자원 분배
5. 올바른 실행및 검증
6. 동기화
7. 확정성(결정성)

임계 구역

임계구역은 여러 프로세스 또는 스레드가 공유 자원에 접근하는 코드의 특정 부분을 의미, 공유 자원에 접근할 때 임계구역을 설정하면 여러 프로세스가 동시에 이 자원에 접근하는걸 방지해 데이터 무결성 유지가 가능
이 문제를 해결하려면 밑 3가지 문제가 해결되어야 한다!

- 상호배제
- 한정된 대기
- 진행

1. 상호배제 1단계 알고리즘

상호 배제 1단계 알고리즘(Turn-based Algorithm)은 두 개의 프로세스가 서로 번갈아 가며 임계구역에 진입하도록 하는 간단한 상호 배제 알고리즘. 이 알고리즘은 두 프로세스가 공유 자원에 동시에 접근하지 않도록 **TURN 변수**를 사용해 관리합니다. 이 방식에서는 TURN 변수를 통해 어느 프로세스가 임계구역에 들어갈 차례인지를 정해줍니다.

 1단계 알고리즘 작동 방식

1. **TURN 변수**: TURN 변수는 현재 어느 프로세스가 임계구역에 들어갈 차례인지 나타냅니다. `TURN = 0`이면 프로세스 P0가 진입할 차례이고, `TURN = 1`이면 프로세스 P1이 진입할 차례.
    
2. **임계구역 진입 조건**: 각 프로세스는 자신의 차례가 될 때까지 기다리며, TURN 변수의 값이 자신의 프로세스 번호와 같으면 임계구역에 진입할 수 있습니다.
    
3. **임계구역 종료 후 TURN 변경**: 임계구역을 벗어난 프로세스는 TURN 값을 상대방 프로세스 번호로 변경하여 상대방이 임계구역에 진입할 수 있도록 합니다.

요약 : turn 을 받을때 까지 기다림, 본인의 차례가오면 공유자원에 접근하여 할일을 마치고 상대에게 차례를 넘김 이를 반복

- 장점: 구현이 매우 단순함
- 단점: 두 프로세스가 **번갈아 가며** 자원에 접근하는 구조이기 때문에 한 프로세스가 임계구역을 필요로 하지 않아도 상대방 프로세스가 기다려야 하는 **비효율성**이 발생


2. 상호배제 2단계 알고리즘

**상호 배제 2단계 알고리즘(Flag-based Algorithm)**은 두 프로세스가 공유 자원에 동시에 접근하지 않도록 `FLAG` 배열만을 사용해 구현합니다. `FLAG` 배열을 통해 각 프로세스가 임계구역에 들어가려는지 여부를 표시하고, 두 프로세스가 동시에 접근하는 것을 방지합니다.


 2단계 알고리즘 작동 방식

- **FLAG 배열**: 두 프로세스(P0와 P1) 각각이 `FLAG` 배열의 인덱스에 자기 상태를 표시합니다.
    - `FLAG[0]`은 프로세스 P0의 상태를, `FLAG[1]`은 프로세스 P1의 상태를 나타냅니다.
    - `FLAG` 값이 `true`이면 해당 프로세스가 임계구역에 진입하려고 하는 상태임을 의미합니다.

 알고리즘 동작 과정

1. 프로세스가 임계구역에 들어가기를 원하면 해당 `FLAG` 값을 `true`로 설정합니다.
2. 이후 상대방 프로세스의 `FLAG` 값이 `true`인지 확인합니다.
    - 상대방이 임계구역에 들어가려는 상태이면 기다립니다.
3. 상대방 프로세스의 `FLAG` 값이 `false`이면 임계구역에 들어갈 수 있습니다.
4. 임계구역에서 나올 때 자신의 `FLAG` 값을 `false`로 설정하여 임계구역 진입 의사를 철회합니다.

요약 : 본인의 flag를 참으로 놓으면서 진입의사 표시, 상대의 자원접근이 종료되고 상대방  flag 가 false 가 되자마자 진입

- **장점**:
    - 단순히 `FLAG` 배열만으로 상호 배제를 구현할 수 있어 구조가 간단합니다.
    - 두 프로세스가 동시에 임계구역에 들어가지 않도록 합니다.
- **단점**:
    - **기아 상태(Starvation)** 발생 가능성: 두 프로세스가 동시에 임계구역에 진입하려고 하면 무한 대기 상태가 발생할 수 있습니다.
    - **데드락 가능성**: 상대방이 임계구역을 포기하지 않으면 무한 대기가 발생할 수 있습니다.


3. 3단계 알고리즘

상호배제 3단계 데커 알고리즘(Dekker's Algorithm)**은 두 개의 프로세스가 공유 자원에 동시 접근하는 것을 방지하는 상호 배제 알고리즘으로, **상호 배제, 진행, 유한 대기**를 보장하는 최초의 알고리즘 중 하나입니다. 데커 알고리즘은 두 개의 프로세스가 서로 번갈아 임계구역에 들어갈 수 있도록 `FLAG` 배열과 `TURN` 변수를 조합해 상호 배제를 구현합니다.

1. **FLAG 배열**: 각 프로세스가 임계구역에 들어가고자 하는 의사를 나타냅니다.
    
    - `FLAG[0]`: 프로세스 P0의 진입 의사.
    - `FLAG[1]`: 프로세스 P1의 진입 의사.
    - `FLAG[i]`가 `true`면 프로세스 `i`가 임계구역에 진입하려고 하는 상태입니다.
2. **TURN 변수**: 두 프로세스가 동시에 임계구역에 들어가려고 할 때, 누구에게 우선권이 있는지를 나타냅니다.
    
    - `TURN = 0`이면 P0에게 우선권이 있고, `TURN = 1`이면 P1에게 우선권이 있습니다.

### 데커 알고리즘 작동 방식

데커 알고리즘은 각 프로세스가 자신의 `FLAG`를 통해 임계구역 진입 의사를 표시하고, **상대방의 `FLAG`와 `TURN`을 확인하여 임계구역에 진입할 수 있는지 결정**합니다. 


 데커 알고리즘의 주요 구성 요소
1. **FLAG 배열**: 각 프로세스가 임계구역에 들어가고자 하는 의사를 나타냅니다.
    
    - `FLAG[0]`: 프로세스 P0의 진입 의사.
    - `FLAG[1]`: 프로세스 P1의 진입 의사.
    - `FLAG[i]`가 `true`면 프로세스 `i`가 임계구역에 진입하려고 하는 상태입니다.
2. **TURN 변수**: 두 프로세스가 동시에 임계구역에 들어가려고 할 때, 누구에게 우선권이 있는지를 나타냅니다.
    
    - `TURN = 0`이면 P0에게 우선권이 있고, `TURN = 1`이면 P1에게 우선권이 있습니다.
요약 : 2단계 알고리즘에서 둘 모두가 true 일 경우 생기는 교착상태 예방을 위하여 turn 개념을 도입한 알고리즘, flag가 true 면 진입하되, 상대의 진입의사를 확인, 상대의 진입의사가 참이면 내 우선권(turn)를 철회하고, 대기, 상대의 진입의사가 없으면 내가 진행

- **장점**:
    
    - **상호 배제**: 두 프로세스가 동시에 임계구역에 진입할 수 없습니다.
    - **진행 보장**: 임계구역에 진입할 프로세스가 없다면, 대기 중인 프로세스는 임계구역에 들어갈 수 있습니다.
    - **유한 대기 보장**: 특정 프로세스가 임계구역에 진입하기 위해 무한히 대기하지 않도록, TURN 변수를 사용해 번갈아가며 우선권을 부여합니다.
- **단점**:
    
    - 두 프로세스에만 적용 가능한 알고리즘입니다. 여러 프로세스에 대한 확장이 어렵습니다.
    - 구현이 다소 복잡하여 실수할 가능성이 있으며, 프로세스 수가 늘어날수록 효율이 떨어집니다.

지금까지의 알고리즘들은 2가지 프로세스에서만 적용가능하다는 단점을 공유했습니다. 이제부터 소개할 세마포어는 다익스트라가 제안한 프로세스가 n개 일때도 적용가능한 기법입니다.

번외) 하드웨어 단 임계구역 
**Test-and-Set**은 하드웨어에 의해 지원되는 동기화 원자로, 주로 **상호 배제**를 구현하는 데 사용됩니다. 이 기법은 **원자적(atomic)** 연산을 통해 동시에 여러 프로세스가 임계구역에 접근하는 것을 방지합니다. Test-and-Set은 매우 간단하고 효율적인 알고리즘으로, 주로 프로세스의 상태를 변경하는 데 사용됩니다.

 Test-and-Set 작동 방식

**Test-and-Set**은 두 가지 동작을 한 번의 원자적 연산으로 수행합니다:

1. 특정 변수(일반적으로 `lock`이라고 불림)의 현재 값을 읽습니다.
2. 이 변수를 설정하여 "잠김" 상태를 표시합니다.
원자적(비트단위) 연산임으로 도중에 방해받는 일이 없습니다.



4. 세마포어

**세마포어(Semaphore)**는 다수의 프로세스가 공유 자원에 접근할 때 발생하는 **경쟁 상태**를 방지하기 위해 사용되는 동기화 기법입니다. 세마포어는 **정수 변수**를 기반으로 하며, 여러 프로세스가 동시에 접근할 수 있는 자원의 수를 제한하거나 하나씩 접근할 수 있도록 제어합니다.

세마포어는 아래 두 가지 기본 연산을 통해 자원 접근을 제어합니다:

1. **P 연산 (proberen, 테스트)**:
    
    - 세마포어 값을 감소시키는 연산입니다.
    - 세마포어 값이 0 이상이면, 해당 프로세스는 자원에 접근할 수 있습니다.
    - 세마포어 값이 0이면, 자원이 사용 중임을 의미하며, 프로세스는 대기 상태에 놓입니다.
2. **V 연산 (verhogen, 증가)**:
    
    - 세마포어 값을 증가시키는 연산입니다.
    - 프로세스가 자원 사용을 마치면 V 연산을 수행하여, 자원을 사용하려는 다른 프로세스가 접근할 수 있게 합니다.

이 연산들은 원자적(atomic)(비트단위)으로 수행되므로, 중간에 다른 연산이 끼어들지 않아 동시성 문제가 발생하지 않습니다.

요약 세마포어(자원)의 값이 1이면 자원이 존재, 사용하게둠, 0이면 자원이 없음(대기시켜야됨) 사용을 마치면 자원을 다시 리젠

이때 대기 상태인 프로세스들은 대기큐에 두고 자원이 생겼으면 대기 큐의 프로세스를 준비상태로 만듬


새마포어는 많은 문제를 해결할수 있다! (생산자 소비자 문제, 읽기 쓰기 문제등)
이들 문제의 공통점은 **공유 자원에 대한 접근 조정**과 관련이 있다는 점
결론적으로 세마포는 공유자원 문제에서 2개 이상의 프로세스의 동기화를 적절하게 수행할수 있는 알고리즘으로 효용성이 매우 높다!

대부분의 언어는 이 세마포어를 지원하고 자바 또한 지원한다!
`acquire()`**와 **`release()`** 연산을 통해 사용가능한데 전자가 바로 빼기 연산 후자가 바로 더하기 연산이다! 
기능들은 모두 동일하며 자바가 지원하는 멀티 스레딩 환경에서의 동기화를 훌륭이 수행할수 있다!


모니터: 감시자

그럼 뭘 감시하냐? 바로 세마포를 감시함!

**Monitor (모니터)**: 객체 내부에 락을 포함시켜 동기화된 메서드나 블록에서만 자원에 접근하도록 함.

- 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단.
- 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal 을 통해 실행 재개

이러한 동기화 메커니즘들은 필연적으로 병목현상을 야기할수 밖에 없다.
여러개의 자동차가 그 수보다 적은 길을 가야하는것이기에...

우리는 이러한 문제를 메세지를 통하여 해결할수 있는데 
송신자와 수신자들끼리의 조율( 도로 트레픽을 제어하는 경찰 역할?)

이때 고려해야하는 문제중 네이밍 문제, 복사문제, 길이 문제등이 있다.

1. 네이밍 문제 : 송신자와 수신자가 서로를 식별할 수 있는 방법의 필요
- 간접네이밍 : 우편함을 이용
- 직접네이밍: 송,수신자가 상대를 명확히 지정
2. 복사문제 : 이때 복사문제는 얕은 복사로 링크만을 공유하면서 생기는 문제

3. 길이 문제 : 고정길이와 가변길이를 고려해야됩니다.