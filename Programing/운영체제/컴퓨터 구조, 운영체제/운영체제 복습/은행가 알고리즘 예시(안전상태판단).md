
### **시스템 정보:**

- **시스템 자원 총합**: (10, 10, 10)
- **각 프로세스의 최대 요구량**과 **현재 할당된 자원**:

|프로세스 번호|최대 자원 요구량 (A, B, C)|현재 할당 자원 (A, B, C)|
|---|---|---|
|P0|(3, 2, 2)|(2, 1, 1)|
|P1|(2, 3, 3)|(1, 1, 1)|
|P2|(3, 2, 2)|(2, 1, 1)|
|P3|(4, 3, 3)|(3, 2, 2)|
|P4|(2, 2, 2)|(2, 1, 1)|

### **단계 1: 남은 자원 계산**

시스템 자원 총합은 (10, 10, 10)이고, 각 프로세스가 이미 할당받은 자원들의 총합을 계산하면:

- **할당된 자원 총합** = (2+1+2+3+2, 1+1+1+2+1, 1+1+1+2+1) = (10, 6, 6)

따라서, **남은 자원**은:

- **남은 자원** = (10, 10, 10) - (10, 6, 6) = (0, 4, 4)

### **단계 2: 각 프로세스의 **남은 요구량** 계산**

각 프로세스가 요청해야 할 자원의 양을 구합니다. 이는 **최대 요구량**에서 **현재 할당된 자원**을 빼면 됩니다.

|프로세스 번호|최대 자원 요구량 (A, B, C)|현재 할당 자원 (A, B, C)|남은 자원 요구량 (A, B, C)|
|---|---|---|---|
|P0|(3, 2, 2)|(2, 1, 1)|(1, 1, 1)|
|P1|(2, 3, 3)|(1, 1, 1)|(1, 2, 2)|
|P2|(3, 2, 2)|(2, 1, 1)|(1, 1, 1)|
|P3|(4, 3, 3)|(3, 2, 2)|(1, 1, 1)|
|P4|(2, 2, 2)|(2, 1, 1)|(0, 1, 1)|

### **단계 3: 자원 할당 순서 찾기 (안전 순서열)**

이제 각 프로세스가 종료될 수 있는지 여부를 확인합니다. 남은 자원이 해당 프로세스의 **남은 자원 요구량**을 만족할 수 있는지 검사합니다. 자원을 할당하고, 해당 프로세스가 종료되면 그 프로세스가 가진 자원은 반환되어 남은 자원에 더해집니다.

1. **P0**: 남은 자원 (0, 4, 4)와 비교했을 때 P0의 남은 요구량 (1, 1, 1)을 만족할 수 없습니다. → P0는 종료 불가
    
2. **P1**: 남은 자원 (0, 4, 4)와 비교했을 때 P1의 남은 요구량 (1, 2, 2)을 만족할 수 없습니다. → P1은 종료 불가
    
3. **P2**: 남은 자원 (0, 4, 4)와 비교했을 때 P2의 남은 요구량 (1, 1, 1)을 만족할 수 없습니다. → P2는 종료 불가
    
4. **P3**: 남은 자원 (0, 4, 4)와 비교했을 때 P3의 남은 요구량 (1, 1, 1)을 만족할 수 있습니다. → P3 종료 가능
    
    - P3 종료 후 반환되는 자원: (3, 2, 2)
    - 새로운 남은 자원: (0, 4, 4) + (3, 2, 2) = (3, 6, 6)
5. **P0**: 새로운 남은 자원 (3, 6, 6)과 비교했을 때 P0의 남은 요구량 (1, 1, 1)을 만족할 수 있습니다. → P0 종료 가능
    
    - P0 종료 후 반환되는 자원: (2, 1, 1)
    - 새로운 남은 자원: (3, 6, 6) + (2, 1, 1) = (5, 7, 7)
6. **P1**: 새로운 남은 자원 (5, 7, 7)과 비교했을 때 P1의 남은 요구량 (1, 2, 2)을 만족할 수 있습니다. → P1 종료 가능
    
    - P1 종료 후 반환되는 자원: (1, 1, 1)
    - 새로운 남은 자원: (5, 7, 7) + (1, 1, 1) = (6, 8, 8)
7. **P2**: 새로운 남은 자원 (6, 8, 8)과 비교했을 때 P2의 남은 요구량 (1, 1, 1)을 만족할 수 있습니다. → P2 종료 가능
    
    - P2 종료 후 반환되는 자원: (2, 1, 1)
    - 새로운 남은 자원: (6, 8, 8) + (2, 1, 1) = (8, 9, 9)
8. **P4**: 새로운 남은 자원 (8, 9, 9)과 비교했을 때 P4의 남은 요구량 (0, 1, 1)을 만족할 수 있습니다. → P4 종료 가능
    
    - P4 종료 후 반환되는 자원: (2, 1, 1)
    - 새로운 남은 자원: (8, 9, 9) + (2, 1, 1) = (10, 10, 10)

### **안전 순서열**

- **P3, P0, P1, P2, P4** 순서로 프로세스들이 자원을 반환하며 종료됩니다.
- 따라서, 이 시스템의 **안전 순서열(Safe Sequence)**은 **P3 → P0 → P1 → P2 → P4**입니다.

### **시스템 정보 (교착 상태 발생 예시)**:

- **시스템 자원 총합**: (10, 10, 10)
- **각 프로세스의 최대 요구량**과 **현재 할당된 자원**:

|프로세스 번호|최대 자원 요구량 (A, B, C)|현재 할당 자원 (A, B, C)|
|---|---|---|
|P0|(3, 3, 2)|(2, 1, 1)|
|P1|(3, 2, 2)|(2, 1, 1)|
|P2|(3, 2, 3)|(2, 1, 2)|
|P3|(3, 3, 3)|(3, 2, 2)|
|P4|(2, 2, 2)|(1, 1, 1)|

### **단계 1: 남은 자원 계산**

시스템 자원 총합은 (10, 10, 10)이고, 각 프로세스가 이미 할당받은 자원들의 총합을 계산하면:

- **할당된 자원 총합** = (2+2+2+3+1, 1+1+1+2+1, 1+1+2+2+1) = (10, 5, 7)

따라서, **남은 자원**은:

- **남은 자원** = (10, 10, 10) - (10, 5, 7) = (0, 5, 3)

### **단계 2: 각 프로세스의 남은 요구량 계산**

각 프로세스가 요청해야 할 자원의 양을 구합니다. 이는 **최대 요구량**에서 **현재 할당된 자원**을 빼면 됩니다.

|프로세스 번호|최대 자원 요구량 (A, B, C)|현재 할당 자원 (A, B, C)|남은 자원 요구량 (A, B, C)|
|---|---|---|---|
|P0|(3, 3, 2)|(2, 1, 1)|(1, 2, 1)|
|P1|(3, 2, 2)|(2, 1, 1)|(1, 1, 1)|
|P2|(3, 2, 3)|(2, 1, 2)|(1, 1, 1)|
|P3|(3, 3, 3)|(3, 2, 2)|(0, 1, 1)|
|P4|(2, 2, 2)|(1, 1, 1)|(1, 1, 1)|

### **단계 3: 자원 할당 순서 찾기 (안전 순서열)**

각 프로세스가 종료될 수 있는지 여부를 확인합니다. 남은 자원이 해당 프로세스의 **남은 자원 요구량**을 만족할 수 있는지 검사합니다. 자원을 할당하고, 해당 프로세스가 종료되면 그 프로세스가 가진 자원은 반환되어 남은 자원에 더해집니다.

1. **P0**: 남은 자원 (0, 5, 3)과 비교했을 때 P0의 남은 요구량 (1, 2, 1)을 만족할 수 없습니다. → P0는 종료 불가
2. **P1**: 남은 자원 (0, 5, 3)과 비교했을 때 P1의 남은 요구량 (1, 1, 1)을 만족할 수 없습니다. → P1은 종료 불가
3. **P2**: 남은 자원 (0, 5, 3)과 비교했을 때 P2의 남은 요구량 (1, 1, 1)을 만족할 수 없습니다. → P2는 종료 불가
4. **P3**: 남은 자원 (0, 5, 3)과 비교했을 때 P3의 남은 요구량 (0, 1, 1)을 만족할 수 없습니다. → P3는 종료 불가
5. **P4**: 남은 자원 (0, 5, 3)과 비교했을 때 P4의 남은 요구량 (1, 1, 1)을 만족할 수 없습니다. → P4는 종료 불가

### **단계 4: 안전 순서열 없음**

위 과정을 보면, 어떤 프로세스도 현재 시스템의 남은 자원으로 종료할 수 없습니다. 즉, 시스템은 **교착 상태에 빠져 있으며** 모든 프로세스가 자원을 할당받을 수 없으므로, **안전 순서열(Safe Sequence)**을 찾을 수 없습니다.