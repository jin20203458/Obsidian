
### 하드웨어의 이해

#### 컴퓨터의 구성 요소
1. 중앙처리장치(CPT : Central Processimg Unit)
- 외부에서 정보를 입력받아 컴퓨터 프로그램의 명령어를 해석하고 결과를 반환함으로써 컴퓨터 시스템을 통제하는 중앙처리장치
- 레지스터, ALU, 제어장치로 구성

2. 주기억장치(Main Memory)
- CPU가 처리할 명령어와 데이터를 저장하기 위한 하드웨어 장치
- 휘발성인 RAM(Random Acesss Memory): DynamicRAM,SataticRAM으로 다시 분류,
  와 비휘발성인 ROM(Read Only Memory): Mask ROM,PROM, EPROM 으로 다시 분류,
  로 분류 가능하다. 

3. 입출력장치
- 키보드, 마우스, 모니터..등등 컴퓨터 외부에 연결되어 컴퓨터와 상호작용하는 장치

4. 보조기억장치
- 주기억 장치 속도는 느리나 용량이 크고 비교적 저렴하다. 


#### 리눅스 설치를 위한 하드웨어 요구사항
1. CPU :  
- 리눅스는 CPU 에서 제공하는 어셈블리어와 쉽게 이식 가능한 C 언어로 개발이 진행되고 있다. CPU 종속 특성 부분만 어셈블리어로 구현하고 나머지는 C 로 구성되기에 GNU C 가 지원하는 CPU 환경이라면 이론상 리눅스를 이식,구동할수 있다.
- 배포판마다 지원 여부가 상이함으로 선택한 배포판 사양을 살펴볼 필요가 있다.

2. 메인보드:
- 대부분 메인보드를 지원한다.

3. 메모리(RAM):
- 과거에는 종류에 따라 호환성이 달라지기도 했지만 최근에는 거의 모든 메모리를 지원한다.
- 지원 가능한 용량은 배포판 마다 상이할수 있음을 상기해야 한다.

4. 하드디스크:
- 리눅스는 IDE, E-IDE, SCSI, S-ATA 등 대부분의 인터페이스를 지원한다.

5. 모니터와 그래픽 카드:
- 대부분의 모니터, 그래픽 카드를 별도의 드라이버 설치없이 사용가능
- 시스템에 장착된 그래픽 카드를 알아보는 명령어는 lspci | grep -I vga

6. LAN 카드:
- 대부분의 LAN카드 제공, 네트워크 카드 규격을 지원
7. 키보드,마우스:
- 현존하는 거의 모든 마우스,키보드 지원

### 하드웨어의 선택

#### 1. RAID 개요

RAID(Redundant Array of Independent Disks)는 여러 개의 물리적 디스크를 하나의 논리적 디스크로 결합하여 성능, 데이터 무결성 및 내구성을 향상시키는 기술

##### RAID 0 (스트라이핑)
- **구성**: 데이터 스트라이핑을 사용하여 데이터를 여러 디스크에 분산시킵니다.
- **장점**: 성능이 향상됩니다. 읽기와 쓰기 속도가 빨라집니다.
- **단점**: 데이터 보호가 전혀 없습니다. 하나의 디스크가 손상되면 모든 데이터가 손실됩니다.
- **사용 사례**: 성능이 중요한 경우(예: 비디오 편집, 게임 로딩 등).

##### RAID 1 (미러링)
- **구성**: 데이터를 두 개 이상의 디스크에 동일하게 복사하여 저장합니다.
- **장점**: 데이터 복원력이 뛰어납니다. 한 디스크가 손상되어도 다른 디스크에서 데이터를 복구할 수 있습니다.
- **단점**: 저장 효율이 낮습니다. 저장 용량이 절반으로 줄어듭니다.
- **사용 사례**: 데이터 안전이 중요한 경우(예: 중요한 문서 저장, 데이터베이스 등).

##### RAID 2 (비트-레벨 스트라이핑과 해밍 코드 ECC)
- **구성**: 비트 수준에서 데이터를 스트라이핑하고, 오류 수정 코드를 사용하여 데이터 무결성을 보장합니다.
- **장점**: 높은 오류 수정 능력.
- **단점**: 구현이 복잡하고, 현대 시스템에서 거의 사용되지 않습니다.
- **사용 사례**: 현재는 거의 사용되지 않음.

##### RAID 3 (바이트-레벨 스트라이핑과 단일 패리티 디스크)
- **구성**: 바이트 수준에서 데이터를 스트라이핑하고, 하나의 디스크에 패리티 정보를 저장합니다.
- **장점**: 높은 데이터 전송 속도.
- **단점**: 하나의 디스크에 패리티를 집중시켜 병목 현상이 발생할 수 있습니다.
- **사용 사례**: 대용량 스트리밍 데이터 처리(예: 비디오 스트리밍).

##### RAID 4 (블록-레벨 스트라이핑과 단일 패리티 디스크)
- **구성**: 블록 수준에서 데이터를 스트라이핑하고, 하나의 디스크에 패리티 정보를 저장합니다.
- **장점**: 데이터 복구 능력이 있습니다.
- **단점**: 패리티 디스크가 병목 현상을 초래할 수 있습니다.
- **사용 사례**: 대규모 데이터 읽기 작업이 많은 경우.

##### RAID 5 (블록-레벨 스트라이핑과 분산 패리티)
- **구성**: 블록 수준에서 데이터를 스트라이핑하고, 패리티 정보를 모든 디스크에 분산시켜 저장합니다.
- **장점**: 읽기 성능이 뛰어나며, 디스크 하나가 손상되어도 데이터 복구가 가능합니다.
- **단점**: 쓰기 성능이 패리티 계산 때문에 다소 낮아질 수 있습니다.
- **사용 사례**: 일반적인 파일 서버, 데이터베이스 서버 등.

##### RAID 6 (블록-레벨 스트라이핑과 이중 분산 패리티)
- **구성**: RAID 5와 유사하지만, 두 개의 독립적인 패리티 스킴을 사용하여 데이터를 보호합니다.
- **장점**: 두 개의 디스크가 손상되어도 데이터 복구가 가능합니다.
- **단점**: 쓰기 성능이 더 낮아질 수 있으며, RAID 5보다 더 많은 디스크 공간을 사용합니다.
- **사용 사례**: 데이터 안정성이 매우 중요한 환경(예: 엔터프라이즈 서버).

##### RAID 01 (RAID 0+1, 스트라이핑과 미러링 결합)
- **구성**: 먼저 RAID 0으로 스트라이핑한 후, RAID 1로 미러링합니다.
- **장점**: 성능과 데이터 복원력이 뛰어납니다.
- **단점**: 저장 효율이 낮고, RAID 10보다 복구 능력이 떨어질 수 있습니다.
- **사용 사례**: RAID 10과 유사한 환경이지만, 데이터 복구가 RAID 10보다 약간 더 복잡합니다.

##### RAID 10 (RAID 1+0, 미러링과 스트라이핑 결합)
- **구성**: 먼저 RAID 1로 미러링한 후, RAID 0으로 스트라이핑합니다.
- **장점**: 성능과 데이터 복원력이 뛰어납니다.
- **단점**: 저장 효율이 낮고, 많은 디스크가 필요합니다.
- **사용 사례**: 고성능과 데이터 보호가 모두 중요한 경우(예: 고성능 데이터베이스 서버).

##### RAID 53 (RAID 3+0 ) 구성
1. **RAID 3 Arrays**: 먼저, 여러 개의 RAID 3 어레이를 만듭니다. RAID 3는 바이트 수준의 스트라이핑과 단일 패리티 디스크를 사용하여 데이터를 저장합니다.
2. **RAID 0 Striping**: 그런 다음, 이 RAID 3 어레이들을 RAID 0 방식으로 스트라이핑합니다. 즉, 각 RAID 3 어레이가 하나의 단위로 간주되며, 이러한 단위들을 RAID 0 방식으로 결합하여 전체 스토리지 시스템을 구성합니다.

 **장점**
- **높은 성능**: RAID 0의 스트라이핑 덕분에 읽기와 쓰기 성능이 크게 향상됩니다.
- **데이터 보호**: 각 RAID 3 어레이 내에서 패리티 디스크를 통해 데이터 보호가 가능합니다. 단일 디스크 실패 시 데이터 복구가 가능합니다.
- **대용량 지원**: 여러 디스크를 결합하여 큰 저장 용량을 제공할 수 있습니다.

 **단점**
- **복잡한 구성**: RAID 53은 구성과 관리가 복잡합니다.
- **높은 비용**: 많은 디스크가 필요하며, RAID 3와 RAID 0을 결합한 형태라서 구현 비용이 높습니다.
- **패리티 병목**: RAID 3 어레이 내에서 패리티 디스크가 병목 현상을 초래할 수 있습니다.

 **사용 사례:** 대규모 데이터 처리와 고성능이 필요한 환경

#### 2. 디스크 인터페이스

1. **IDE:** 가장 오레된 규격으로 40개의 핀으로 구성된 병렬 인터페이스다.
   초기형보다 성능이 향상된 E-IDE(133.3MB/s가 있다.

2. **S-ATA:** IDE 의 성능 한계를 극복하기 위해 직렬로 데이터를 전송한다.
- SATA 1: 150MB/s, SATA2: 300MB/s, SATA3:6GB/s

3. SCSI(Small Computer System Interface)
- 고성능과 언정성, 신뢰성을 중요하는 워크 스테이션 및 서버 시장에서 주로 사용하던 디스크 인터페이스다.
- 병렬 전송방식이며 그에따른 한계 존재

4. SAS(Serial Attached SCSI)
- SCSI의 한계를 극복하기 위해 시리얼 방식을 도입한 디스크 인터페이스다.
- 안정성, 신뢰성을 이어가며 속도를 향상시켰다.

#### 3. LVM(Logical Volume Manager) 
**물리적 스토리지 디스크를 논리적인 볼륨(Logical Volume)으로 추상화**

![[Pasted image 20240623030132.png]]
Linux 환경에서 디스크 공간 관리를 유연하고 효율적으로 할 수 있게 해주는 시스템입니다.(블록단위) LVM을 사용하면 물리적 디스크를 논리적으로 관리할 수 있으며, 디스크 공간을 쉽게 확장하거나 축소하고, 데이터의 안전성과 성능을 향상시킬 수 있습니다.

### LVM의 주요 구성 요소

1. **Physical Volume (PV)**:
    
    - 물리적 볼륨으로, 실제 하드 드라이브 또는 파티션을 나타냅니다.
    - `pvcreate` 명령어로 생성됩니다.
2. **Volume Group (VG)**:
    
    - 여러 개의 Physical Volume을 하나의 그룹으로 묶은 것입니다.
    - `vgcreate` 명령어로 생성됩니다.
    - VG는 여러 PV의 집합으로, 이들로부터 논리 볼륨을 만들 수 있습니다.
3. **Logical Volume (LV)**:
    
    - 사용자가 실제로 데이터를 저장하는 논리적 파티션입니다.
    - `lvcreate` 명령어로 생성됩니다.
    - LV는 VG에서 할당된 공간을 기반으로 만들어지며, 마치 일반 파티션처럼 파일 시스템을 생성하고 데이터를 저장할 수 있습니다.
4. **Physical Extent (PE)**:
    
    - PV를 구성하는 기본 블록 단위입니다.
    - 기본적으로 4MB 크기를 가집니다.
    - PV는 여러 PE로 나뉘며, VG는 PE 단위로 공간을 관리합니다.
5. **Logical Extent (LE)**:
    
    - LV를 구성하는 기본 블록 단위입니다.
    - LE는 PE와 일대일로 매핑됩니다.