좋아 형진! 이번엔 Java 언어의 기본 중 기본인 **자료형(Data Types)**을 확실히 정리해볼게요 ☕  
C와 비교하면 **객체지향 + 정적 자료형 시스템**이란 특성이 더해지기 때문에 이해 포인트가 조금 달라요.

---

### 📦 Java의 자료형은 크게 2가지로 나뉘어!

|분류|종류|특징|
|---|---|---|
|**기본형(Primitive)**|`int`, `float`, `char`, `boolean` 등|C처럼 **값 자체를 저장**|
|**참조형(Reference)**|클래스, 배열, 인터페이스, 열거형 등|**객체의 주소(참조값)를 저장**|

---

### 🧱 Java의 기본형 데이터 타입 (총 8개)

|자료형|크기|예시|설명|
|---|---|---|---|
|`byte`|1바이트|127|-128~127 범위의 정수|
|`short`|2바이트|32000|-32,768~32,767|
|`int`|4바이트|100000|가장 흔히 쓰이는 정수형|
|`long`|8바이트|123456789L|큰 정수 저장 (L 붙임)|
|`float`|4바이트|3.14f|실수형 (f 붙임)|
|`double`|8바이트|3.141592|기본 실수형|
|`char`|2바이트|'A'|유니코드 문자 한 글자 저장|
|`boolean`|1바이트|true/false|논리형 (조건문에 자주 사용)|

> Java에서는 `char`도 유니코드 기반이기 때문에 한글 같은 다국어 문자도 저장 가능해! 😮

---

### 🧭 기본형 vs 참조형 차이

|항목|기본형|참조형|
|---|---|---|
|저장 내용|값 자체|객체 주소|
|null 가능 여부|❌|✅ (객체가 없을 수도 있음)|
|비교 방식|`==`로 값 비교|`==`는 주소 비교, `equals()`는 값 비교|
|메모리|스택 영역|힙 영역 (일반적으로)|

---

### 📚 예시 코드

```java
int age = 25;           // 기본형
String name = "형진";    // 참조형

System.out.println(name + "의 나이는 " + age + "살입니다.");
```

---

### 🎯 시험 및 실무 포인트

- Java는 **모든 기본형을 제외하면 모두 객체(참조형)**!
- 문자열은 `String`, 배열은 `int[]`, 사용자 정의 객체 등은 전부 참조형
- 기본형은 **Wrapper 클래스** (`Integer`, `Double` 등)로 감쌀 수 있어 → 오토박싱/언박싱 지원
- Java는 **메모리 안전성, 자료형 명확성**을 중요시하기 때문에 형 변환 시에도 엄격해!

---

좋아 형진! 이번엔 Java에서 매우 중요한 개념인 **인터페이스(Interface)**에 대해 확실하게 정리해볼게요 🎯  
객체지향에서 다형성과 설계 유연성을 높이기 위해 꼭 알아야 할 핵심이에요.

---

### 🧠 인터페이스란?

- **"기능의 설계도"** 역할을 하는 **추상적인 타입**
- 클래스가 특정 인터페이스를 **구현(implements)**하면, 그 인터페이스에 정의된 **메서드들을 반드시 구현**해야 해요
- **다형성(polymorphism)**과 **유연한 코드 설계**를 위해 사용

```java
interface Animal {
    void sound();  // 추상 메서드 (구현부 없음)
}
```

---

### 🛠️ 인터페이스 사용 예시

```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("멍멍");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("야옹");
    }
}
```

→ 이제 `Animal` 타입으로 `Dog`, `Cat` 모두 다룰 수 있음 → **다형성의 구현**

```java
Animal a = new Dog();  
a.sound();  // 출력: 멍멍
```

---

### 📦 인터페이스 특징

|항목|설명|
|---|---|
|**추상화**|메서드만 선언하고 구현은 없음 (JDK 8 이후 기본/정적 메서드는 허용됨)|
|**다중 구현 가능**|클래스는 **여러 개의 인터페이스를 구현**할 수 있음 (다중 상속 해결책!)|
|**접근 제어자 생략 가능**|인터페이스 내의 메서드는 기본적으로 `public abstract`로 간주됨|
|**상수 선언 가능**|변수는 `public static final`로 자동 처리됨 (변경 불가한 상수)|

---

### 🔄 인터페이스 vs 추상 클래스 비교

|항목|인터페이스|추상 클래스|
|---|---|---|
|키워드|`interface`|`abstract class`|
|필드|상수만 가능|변수 + 상수 가능|
|메서드|전부 추상 (JDK 8 이후 일부 default/static 허용)|일반 메서드 + 추상 메서드 혼합 가능|
|상속|다중 구현 가능|단일 상속만 가능|
|목적|**기능 규약 제공 (표준화)**|**공통 기능 구현 + 확장성**|

---

### ✅ 시험 & 실무 포인트

- `implements` 키워드는 인터페이스를 **구현**
- 인터페이스는 인스턴스를 생성할 수 없음 (`new Interface()` ❌)
- 클래스는 여러 개의 인터페이스를 `,`로 구분하여 동시에 구현 가능
    
    ```java
    class Robot implements Walkable, Speakable { ... }
    ```
    
- JDK 8 이후부터 `default` 키워드로 **기본 메서드 정의 가능**
- JDK 9 이후엔 `private` 메서드도 정의할 수 있음 (캡슐화 강화)

---

### 🎯 기억 꿀팁

> **인터페이스는 “무엇을 할 수 있는지”를 약속하는 계약서다!**  
> 실제 “어떻게 하는지는” 클래스가 구현한다!

---

요약 비교: Java vs C++ 열거형

|항목|Java `enum`|C++ `enum`|
|---|---|---|
|타입|**객체형 (클래스 기반)**|정수형 상수|
|자동 문자열화|가능 (`toString()`)|불가능 (직접 매핑 필요)|
|메서드 정의|✅ 가능|❌ 기본 enum은 메서드 없음|
|메모리 의미|힙에 객체 생성 (상수처럼 취급)|컴파일타임 상수로 취급|
|개선형|-|`enum class` (C++11~)|


|항목|정적 배열 (`int[]`)|동적 배열 (`ArrayList`)|
|---|---|---|
|크기 변경|❌ 불가능|✅ 자동 확장|
|선언 방식|`int[] arr = new int[5];`|`ArrayList list = new ArrayList<>();`|
|요소 추가|인덱스로 직접 할당|`.add()` 메서드 사용|
|기본형 저장|✅ 가능|❌ 불가 (→ Wrapper 클래스 필요)|
|성능|빠름 (고정된 메모리)|다소 느림 (동적 확장 오버헤드)|
|유연성|낮음|높음|

🧠 정적 배열은 언제 쓰고, 동적 배열은 언제 쓸까?

|상황|추천|
|---|---|
|데이터 크기가 **미리 정해져 있음**|정적 배열|
|데이터 **추가/삭제가 자주 발생**|동적 배열 (`ArrayList`)|
|알고리즘 문제, 성능 민감한 로직|정적 배열|
|실무 애플리케이션 개발|`ArrayList`, `LinkedList` 등 컬렉션 사용 권장|
자바에서 문자열이란?

- Java에서 문자열은 **객체(Object)**야
- 내부적으로 **문자(char)의 배열**로 구성되고, **불변(immutable)** 특성을 가짐
- 즉, 한 번 생성된 문자열은 **수정 불가**! → 수정하는 것처럼 보여도 **새로운 문자열 객체가 생성됨**