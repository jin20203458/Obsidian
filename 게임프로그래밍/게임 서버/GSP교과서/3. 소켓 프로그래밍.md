### **1. 블로킹 소켓 (Blocking Socket)**

블로킹 소켓은 **소켓의 작업이 완료될 때까지 다른 작업을 차단**하는 방식입니다. 즉, **읽기/쓰기 작업**이 완료될 때까지 호출한 스레드가 기다립니다.

#### **특징**

- **읽기 작업**: 데이터를 받을 준비가 되지 않으면 소켓은 **대기 상태**에 들어가고, 데이터가 준비될 때까지 기다립니다.
- **쓰기 작업**: 데이터가 전송될 준비가 될 때까지 소켓은 **대기 상태**에 들어갑니다. 즉, 데이터를 모두 전송할 때까지 기다립니다.
- 주로 **단순한 서버/클라이언트 구조**에서 사용됩니다.
- 동기적(Synchronous) 방식으로 동작합니다.



### **2. 논블로킹 소켓 (Non-blocking Socket)**

논블로킹 소켓은 **읽기/쓰기 작업**을 요청했을 때, 작업이 **완료되지 않았다고 하더라도 즉시 반환**합니다. 즉, **데이터가 준비되지 않으면 바로 반환하고**, **데이터 준비가 되면 다시 확인하는 방식**입니다.

#### **특징**

- **읽기 작업**: 데이터가 준비되어 있지 않으면, 소켓은 **대기하지 않고 즉시 반환**하며, 애플리케이션은 다시 소켓을 확인하여 데이터가 준비되었는지 확인합니다.
- **쓰기 작업**: 데이터가 준비되었는지 즉시 확인하고, 준비되지 않았다면 즉시 반환합니다.
- **폴링(Polling)** 방식으로 자주 사용되며, **select()**나 **poll()** 같은 함수와 결합해 사용됩니다.
- 비동기적(Asynchronous) 방식으로 동작합니다.

-------------
### 🔑 **`select()`란?**

`select()`는 **다수의 소켓(파일 디스크립터)을 동시에 감시하여, 읽기, 쓰기, 예외 상황**이 발생했는지 여부를 체크합니다.

즉, 여러 개의 소켓 중에서 **데이터가 준비된 소켓만 처리**하도록 만들어 CPU 사용률을 높이고 불필요한 대기를 줄입니다.
```
int select( 

int nfds,                 // 감시할 파일 디스크립터의 개수 
fd_set *readfds,          // 읽기 이벤트 감시 소켓 리스트 
fd_set *writefds,         // 쓰기 이벤트 감시 소켓 리스트 
fd_set *exceptfds,        // 예외 이벤트 감시 소켓 리스트
struct timeval *timeout   // 타임아웃 값 (NULL이면 무한 대기) 

);
```
### ✅ **select() 모델 원리**

👉 select() 모델은 **I/O 멀티플렉싱 방식**입니다.
Polling

**동작 과정**:

1. **모든 소켓을 리스트에 등록**합니다.
2. `select()` 함수가 리스트에 등록된 모든 소켓을 **폴링(Polling)** 방식으로 감시합니다.
3. 소켓에 데이터가 준비되었거나 연결이 끊어진 경우에만 반환합니다.
4. 반환된 소켓만 데이터 송수신 작업을 수행합니다.

### 🔑 **핵심 원리**

- CPU가 모든 소켓을 **동기적으로 검사**합니다.
- 데이터가 없는 소켓도 검사하기 때문에 **불필요한 자원 소모**가 발생합니다.
- 다수의 클라이언트가 접속하면 성능이 **급격히 저하**됩니다.

---
## ✅ 2. **WSAEventSelect 방식**

### 🔑 **원리**

WSAEventSelect는 **I/O 멀티플렉싱 기반의 비동기 모델**입니다.

👉 select() 모델처럼 **Polling 방식**을 사용하지만, 이벤트 객체를 통해 상태를 감시합니다.

---

### **Overlapped I/O 모델 설명 (Windows 비동기 소켓 프로그래밍)**

### ✅ **Overlapped I/O 모델 원리**

👉 Overlapped I/O는 **비동기 소켓 통신 방식**입니다.
Event-driven (이벤트 기반)

**동작 과정**:

1. 클라이언트로부터 데이터를 수신할 때 **WSARecv()** 함수를 호출하고, 작업 요청만 한 뒤 바로 반환합니다.
2. 작업이 완료되면 **이벤트 객체(Event Object)**가 시그널 상태로 변경됩니다.
3. `WSAWaitForMultipleEvents()` 함수가 이벤트 객체를 감시합니다.
4. 시그널 상태가 된 이벤트 객체만 처리합니다.
5. 작업 완료 여부는 **WSAGetOverlappedResult()** 함수로 확인합니다.

### 🔑 **핵심 원리**

- 작업을 요청만 하고 바로 반환하므로 CPU가 다른 작업을 수행할 수 있습니다.
- 데이터가 준비된 소켓만 처리하기 때문에 **불필요한 자원 소모가 없음**.
- 클라이언트 수가 많아도 **성능 저하가 거의 없음**.
![[Pasted image 20250305231101.png]]
----

### **IOCP의 기본 개념**

IOCP는 **비동기 I/O 작업의 완료를 처리하는 고급 메커니즘**입니다. 여러 I/O 작업이 비동기적으로 수행되며, 작업이 완료되면 해당 작업을 처리할 수 있도록 **완료 포트(Completion Port)**에 작업 정보를 큐잉하고, 이를 **스레드 풀**에서 처리하는 구조입니다.

### **IOCP의 원리**

1. **I/O 요청과 Overlapped I/O**:
    
    - IOCP는 **Overlapped I/O** 모델을 기반으로 합니다. 즉, I/O 작업이 **비동기적으로** 수행되며, `ReadFile`, `WriteFile`, `WSASend`, `WSARecv` 등과 같은 비동기 I/O 함수를 사용하여 작업을 수행합니다.
    - 각 비동기 I/O 작업은 **Overlapped 구조체**를 통해 시작되며, 작업이 완료되면 완료 상태를 **완료 포트**에 쌓아두고 스레드가 이를 처리합니다.
2. **완료 포트(Completion Port)**:
    
    - **완료 포트**는 I/O 작업이 완료되었을 때 그 결과를 대기하는 **큐**입니다. 각 I/O 작업은 완료되면 **완료 포트에 큐에 저장**됩니다.
    - 완료 포트는 **비동기 I/O 작업의 결과를 전달**받고, 해당 작업에 대한 정보를 다른 프로세스나 스레드가 받을 수 있게 합니다.
3. **스레드 풀(Thread Pool)**:
    
    - IOCP는 **스레드 풀**을 사용하여 **비동기 I/O 작업**을 처리합니다. 여러 개의 스레드가 완료 포트를 모니터링하며, 큐에 저장된 완료된 작업을 하나씩 처리합니다.
    - 스레드 풀은 **동적으로 스레드를 관리**하며, 완료된 작업을 효율적으로 분배하여 작업을 병렬로 처리할 수 있습니다.
4. **작업 완료 후 스레드 처리**:
    
    - I/O 작업이 완료되면 해당 작업은 **완료 포트에 쌓이고**, **스레드 풀**의 스레드는 이 큐에서 작업을 하나씩 가져와 처리합니다.
    - `GetQueuedCompletionStatus()`를 호출하면 **완료 포트 큐**에서 완료된 작업을 가져오며, 이 함수는 **블로킹 방식**으로 동작하여 큐에 작업이 없으면 대기합니다.

### **IOCP의 흐름**

1. **I/O 요청 시작**:
    
    - 서버는 클라이언트 요청을 받으면 **비동기 I/O 작업**을 수행하기 위해 **Overlapped I/O**를 사용하여 작업을 시작합니다. 예를 들어, `WSARecv()`나 `WSASend()`와 같은 비동기 함수로 데이터를 송수신합니다.
2. **완료 포트와 연결**:
    
    - 클라이언트의 각 소켓은 `CreateIoCompletionPort()`를 사용하여 **완료 포트**와 연결됩니다. 이 연결을 통해, 해당 소켓에서 발생한 I/O 작업이 완료되면 완료 포트에 그 결과가 기록됩니다.
3. **작업 완료 및 큐에 저장**:
    
    - I/O 작업이 완료되면 그 작업은 **완료 포트 큐**에 저장됩니다. 이때 **완료 포트**에는 각 작업에 대한 정보(작업 완료 시점, 관련 데이터 등)가 포함됩니다.
4. **스레드가 큐에서 작업 처리**:
    
    - **스레드 풀**의 스레드들은 `GetQueuedCompletionStatus()` 함수를 사용하여 완료 포트 큐에서 **완료된 작업**을 하나씩 가져옵니다.
    - 이 스레드는 작업이 완료된 소켓에 대해 후속 처리를 합니다. 예를 들어, 받은 데이터를 처리하거나, 송신 완료된 데이터를 클라이언트에게 전송합니다.
5. **반복 처리**:
    
    - 스레드 풀에서 작업을 완료하고 다시 큐에 작업이 쌓이면, 스레드는 이를 계속해서 가져와 처리합니다. 이 과정이 반복되며, 서버는 클라이언트의 다수의 요청을 비동기적으로 효율적으로 처리합니다.
