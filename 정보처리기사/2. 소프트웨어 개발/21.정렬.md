## 내부정렬 vs 외부정렬

|구분|내부정렬 (Internal Sort)|외부정렬 (External Sort)|
|---|---|---|
|정의|모든 데이터를 주기억장치(메인 메모리)에 올려서 정렬|데이터가 너무 많아 메모리에 다 올릴 수 없을 때, 보조기억장치(디스크 등)를 이용해 정렬|
|데이터 양|소량(메모리에 적재 가능한 크기)|대량(메모리보다 큰 데이터)|
|정렬 장소|주기억장치(메인 메모리)|보조기억장치(SSD, HDD 등)|
|속도|빠름|상대적으로 느림|
|대표 알고리즘|버블, 선택, 삽입, 쉘, 퀵, 힙, 병합, 기수 정렬 등|병합정렬(2-way, n-way), 폴리파즈, 균형 병합 등|
|특징|메모리 용량이 한계, 구현 간단|파일을 여러 부분(run)으로 나눠 내부정렬 후 병합 반복|

## 내부정렬 특징

- 모든 데이터가 메모리에 올라와 있을 때 사용[1](https://zinlee.tistory.com/entry/%EC%A0%95%EB%A0%ACSort-%EB%82%B4%EB%B6%80%EC%A0%95%EB%A0%AC-%EC%99%B8%EB%B6%80%EC%A0%95%EB%A0%AC)[2](https://mong9data.tistory.com/39)[3](https://velog.io/@rachell_lee/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%A0%95%EB%A0%AC%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%A2%85%EB%A5%98)[4](https://apluser.tistory.com/30)[5](https://myvelop.tistory.com/160)[8](https://yjhdevelopdiary.tistory.com/169)[9](https://kyeonminsu.tistory.com/26)[10](https://bugoverdose.github.io/computer-science/sorting-basics/).
    
- 속도가 빠르지만, 데이터가 많으면 사용 불가.
    
- 시험에 자주 나오는 알고리즘: 버블, 선택, 삽입, 퀵, 힙, 병합, 기수 정렬 등.
    

## 외부정렬 특징

- 데이터가 너무 커서 메모리에 다 올릴 수 없을 때 사용[1](https://zinlee.tistory.com/entry/%EC%A0%95%EB%A0%ACSort-%EB%82%B4%EB%B6%80%EC%A0%95%EB%A0%AC-%EC%99%B8%EB%B6%80%EC%A0%95%EB%A0%AC)[2](https://mong9data.tistory.com/39)[4](https://apluser.tistory.com/30)[5](https://myvelop.tistory.com/160)[7](https://blog.naver.com/jyk2367/222282293748)[8](https://yjhdevelopdiary.tistory.com/169)[9](https://kyeonminsu.tistory.com/26).
    
- 데이터를 여러 개의 작은 파일(run)로 나누어 각각 내부정렬 후, 보조기억장치에서 병합 반복.
    
- 속도는 느리지만 대용량 데이터 정렬에 적합.
    
- 대표 알고리즘: 병합정렬(Merge Sort) 계열(2-way, n-way, 폴리파즈 등).
    

## 시험 대비 포인트

- 내부정렬: “메모리 내에서 처리, 속도 빠름, 데이터 소량”
    
- 외부정렬: “보조기억장치 활용, 대용량 데이터, 병합정렬 방식으로 처리”
    
- 데이터 크기, 정렬 장소, 대표 알고리즘 구분해서 암기!
    

이 표와 특징만 기억해도 시험 문제에서 내부정렬과 외부정렬을 충분히 구분할 수 있습니다.

### 📌 삽입 정렬 (Insertion Sort)

- **설명**: 데이터를 하나씩 꺼내서 정렬된 부분에 **알맞은 위치에 삽입**하는 방식이에요. 마치 손에 든 카드들을 순서대로 정렬하는 것처럼 생각하시면 됩니다.
    
- **시간복잡도**:
    
    - 최선: O(n) (이미 정렬된 경우)
        
    - 평균 / 최악: O(n²)
        
- **특징**: 소규모 데이터에서 꽤 빠르고, 안정 정렬입니다.
    

### 🫧 버블 정렬 (Bubble Sort)

- **설명**: 옆에 있는 두 값을 비교해서 **더 큰 값을 뒤로 보내는 작업을 반복**해요. 큰 값이 점점 뒤로 ‘버블’처럼 올라가는 모습에서 이름이 붙었어요.
    
- **시간복잡도**:
    
    - 최선: O(n) (한 번도 교환하지 않으면 정지)
        
    - 평균 / 최악: O(n²)
        
- **특징**: 구현은 간단하지만 실제 성능은 가장 떨어져요.
    

### 🔎 선택 정렬 (Selection Sort)

- **설명**: 남은 데이터 중 **가장 작은 값을 선택해 맨 앞과 교환**하는 방식입니다. 반복해서 최솟값을 찾아 자리를 바꾸는 식이에요.
    
- **시간복잡도**:
    
    - 최선 / 평균 / 최악: O(n²)
        
- **특징** : 단순하지만 교환 횟수가 적고, 데이터 이동 비용이 중요한 경우에 유용해요.