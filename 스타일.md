**가) 소스코드 내 해당내용을 자세하고 정확하게 설명할 수 있도록 "제2장 주석및 명명규칙"에 따라 주석을**
**작성하고, 작성 된 주석은 파일별 소스코드의 30%이상으로 한다**.

---

**나) Switch 구문에서 첫번째 Label 전에 코드 구문이 존재하면 안된다.**

### 🚫 잘못된 예제 (위반 사례)
```cpp
void foo(int m)
{
    switch (m)
    {
        n = n + 1; // ❌ 잘못된 위치: 어떤 case label보다 먼저 실행될 수 없음
        case 1:
            --n;
            break;
        default:
            ++n;
            break;
    }
}
```
### ❗ 문제 설명

- `switch` 문 안에서 **어떤** `case` **또는** `default` **label보다 먼저 나오는 코드**는 **절대 실행되지 않습니다**.
- `switch`는 조건에 맞는 label로 **직접 점프**하기 때문에, `n = n + 1;`은 **죽은 코드**(dead code)가 됩니다.
- 일부 컴파일러에서는 경고 또는 오류를 발생시킬 수 있습니다.
### ✅ 올바른 예제 (수정된 코드)
```cpp
void foo(int m)
{
    switch (m)
    {
        case 1:
            --n;
            break;
        default:
            ++n;
            break;
    }
}
```
- `switch` 문 안에는 반드시 `case` **또는** `default` **label이 먼저 나와야** 합니다.
- label 없이 작성된 코드는 **컴파일러가 도달할 수 없는 코드로 간주**합니다.
- 필요한 초기화나 연산이 있다면, `switch` 문 **밖에서** 처리해야 합니다.
---

**다) 함수/변수의 선언 시 type을 명시해야 한다.**

### ❗ 위반 예시 (타입 생략)

```cpp
auto x = 10;         // ❌ 타입이 명시되지 않음
auto foo() {         // ❌ 반환 타입 생략
    return 42;
}
```

- `auto`는 편리하지만, **코드의 명확성을 떨어뜨릴 수 있음**
- 특히 협업이나 코드 리뷰 시 **의도가 불분명**해질 수 있음

### ✅ 올바른 예시 (타입 명시)

```cpp
int x = 10;          // ✅ 타입 명시
int foo() {          // ✅ 반환 타입 명시
    return 42;
}
```

- 타입을 명시하면 **코드의 의미가 명확해지고**, **컴파일러의 타입 추론에 의존하지 않음**
- 유지보수성과 가독성이 향상됨

---

**라) 의미 없는 구문은 사용하지 말아야 한다.(side effect)**
