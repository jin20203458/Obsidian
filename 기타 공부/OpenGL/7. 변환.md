지금까지의 실습에서는 디폴트로 주어진 좌표 공간을 그냥 사용했다. -1 ~ 1 사이의 좁은 공간에 물체를 배치했으면 위치도 항상 중앙의 원점이었다. 이제 좌표 공간과 물체에 변화를 주어 보자. 지금까지는 입체 확인을 위해 회전 변환만 사용해 보았는데 이 절에서 여러 가지 변환을 실습해 볼 것이다.

3차원 공간에 배치된 물체는 이동, 확대, 회전 등 여러 가지로 변화를 줄 수 있으며 보는 각도에 따라 모양이 달라지기도 한다. 좌표 공간 자체도 범위와 증감 방향에 대해 원하는대로 지정할 수 있다. 또 3차원 공간의 장면도 결국은 모니터나 지면에 출력해야 하므로 2차원으로 바꿔야 한다. 이 각각의 과정에서 복잡한 변환이 발생한다. 전체적인 변환 과정은 다음과 같다.

![[Pasted image 20240612001520.png]]

void glMatrixMode(GLenum mode);

인수로 대상 행렬을 지정하며 이를 행렬 모드라고 한다. 이 함수로 지정한 행렬은 이후의 모든 행렬 연산의 대상이 된다. 물론 다른 행렬을 조작하고 싶을 때는 언제든지 행렬 모드를 바꿀 수 있다. 다음과 같은 행렬 모드가 있는데 주로 모델뷰 행렬이나 투영 행렬이 변환 대상이다. 디폴트는 모델뷰 행렬이다.

| 열거형           | 설명                                          |
| ------------- | ------------------------------------------- |
| GL_MODELVIEW  | 모델 뷰 변환 행렬. 이 값이 디폴트이다.                     |
| GL_PROJECTION | 투영 행렬                                       |
| GL_TEXTURE    | 텍스처 행렬                                      |
| GL_COLOR      | 색상 행렬. 단 이 기능은 ARB_imaging 확장 기능이 지원되어야 한다. |
현재 행렬이 무엇인지를 알아내려면 glGet 함수로 GL_MATRIX_MODE를 전달한다. 현재 행렬을 지정한 후 다양한 행렬 조작을 할 수 있다. 앞으로 여러 가지 변환 함수들을 배우겠지만 일단 대표적으로 다음 함수 하나에 대해 알아 보자.

void glLoadIdentity(void);

이 함수는 현재 행렬을 단위 행렬로 만든다. 

단위 행렬은 우하향 대각선 방향만 1이고 나머지 요소는 모두 0인 행렬로서 임의의 행렬을 곱해도 원래 행렬이 계산되는 특수한 행렬이다. 

곰셉의 1, 덧셈의 0과 같은 항등원으로서 연산을 해도 처음값이 유지된다. 현재 행렬을 단위 행렬로 만든다는 것은 **행렬을 리셋한다는 뜻이며 이는 곧 어떠한 변환도 하지 않는다는 뜻이다.** 지금까지 입체 확인을 위해 회전 기능을 사용했던 모든 예제를 보면 다음 두 행의 코드가 있다.

glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

이 코드는 모델뷰 행렬을 리셋한다. DoDisplay를 이전에 실행했을 때 적용했던 회전값을 무시하고 다시 설정하기 위해 리셋을 해야 한다. 이 리셋 코드가 없으면 회전이 계속 누적 적용되어 원하는 대로 회전되지 않는다. 그림을 그리기 전에 화면을 지우는 것과 마찬가지로 **행렬을 사용하기 전에 리셋을 먼저 해야 한다.**

#### 관측 변환

**관측(Viewing)이란 3차원 공간의 장면을 바라본다는 뜻이다.**
관측 변환은 장면을 바라보는 사용자의 위치나 시점, 각도를 변경하는 변환이다. 같은 장면이라도 어디서 어떤 각도로 바라 보는가에 따라 모양이 완전히 달라진다. 마치 장면을 촬영하는 카메라를 이리 저리 옮기는 기법과 유사해서 카메라 변환이라고도 한다. 관측 지점은 다음 함수로 지정한다.

void gluLookAt(
    GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ,
    GLdouble centerX, GLdouble centerY, GLdouble centerZ,
    GLdouble upX, GLdouble upY, GLdouble upZ
);

보다시피 이 함수는 gl의 함수가 아니라 glu의 유틸리티 함수이다. 왜냐하면 이 함수가 아니어도 동일한 효과를 낼 수 있는 방법이 있기 때문이다. 인수가 굉장히 많은 것처럼 보이는데 세 가지 관점에 대해 x, y, z 각 세쌍씩이므로 총 9개의 인수가 필요하다.

eye 좌표는 시선의 좌표 즉, 관찰자의 위치를 나타내는 좌표이다. center는 관찰자가 바라보고 있는 좌표이다. up은 위쪽을 가리키는 업 벡터를 나타낸다. 카메라로 장면을 촬영하고 있다면 카메라가 있는 곳이 eye 좌표이고 카메라가 초점으로 정한 부분이 center 좌표이며 카메라의 각도가 up 벡터이다. 규칙상 up 벡터는 시선과 평행해서는 안된다.

관측지점을 옮기는것은 곧 물체가 멀어진다는 것이다. (나로부터)
내가 멀어지나 물체가 멀어지나 ...

### 모델링 변환

모델링(Modeling) 변환은 3차원 공간에 배치된 물체를 변형한다. 이동, 확대/축소, 회전 등 여러 가지 변환이 있으며 두 가지 이상의 변환을 동시에 적용하기도 한다. 양이 좀 많지만 특별히 어렵지는 않으므로 순서대로 구경만 해 보면 된다.

```
#include <windows.h>
#include <gl/glut.h>

void DoDisplay();
void DoMenu(int value);
int Action;

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutCreateWindow("OpenGL");
    glutDisplayFunc(DoDisplay);
    glutCreateMenu(DoMenu);
    glutAddMenuEntry("변환 없음", 0);
    glutAddMenuEntry("이동", 1);
    glutAddMenuEntry("엉뚱한 위치에 나타나는 이동", 2);
    glutAddMenuEntry("단위 행렬로 리셋", 3);
    glutAddMenuEntry("스택에 저장 및 복구", 4);
    glutAddMenuEntry("확대", 5);
    glutAddMenuEntry("회전", 6);
    glutAddMenuEntry("확대 후 이동", 7);
    glutAddMenuEntry("이동 후 확대", 8);
    glutAddMenuEntry("원점 기준 회전", 9);
    glutAddMenuEntry("제자리 회전", 10);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
    return 0;
}
void DoMenu(int value)
{
    if (value < 100) {
        Action = value;
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glColor3f(1, 1, 1);
        glutPostRedisplay();
        return;
    }
}
void DoDisplay()
{
    // 변환 없음
    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);
    glFlush();

}
```
처음 중앙에 주전자가 있다.
![[Pasted image 20240612003515.png]]
오른쪽으로 0.6만큼 이동시킨 후 똑같은 주전자를 하나 더 그렸다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);
    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612003947.png]]
이번에는 오른쪽뿐만 아니라 가운데 주전자의 위쪽에도 하나를 더 그려 보자. y 축으로 0.5만큼 이동한 곳에 하나 더 그리면 될 것 같다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);

    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);

    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612004144.png]]
? 우리 목적은 x축 0.6간 1개 y축 0.6 간 1개 였는데 대각선에 1개가 그려져있다.

이렇게 되는 이유는 변환이 누적적으로 적용되기 때문이다. 변환 함수는 현재 행렬에 변환 공식을 써 넣으며 현재 행렬은 이후의 모든 출력에 영향을 미친다. 행렬을 리셋하거나 특별히 다른 값으로 바꾸지 않는 한 현재 값이 계속 유지되고 매 호출시마다 행렬에 변환이 가해진다. 먼저 오른쪽으로 0.5 이동했고 다시 위로 0.5 이동했으므로 세번째 주전자는 오른쪽 위로 이동하는 것이다.

이를 해결하려면 행렬을 다시그릴때 마다 초기화 해야한다.
```
void DoDisplay()
{

    glClear(GL_COLOR_BUFFER_BIT);
    glutWireTeapot(0.2);

    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);

    glLoadIdentity(); // 초기화 구문
    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glFlush();
}
```
![[Pasted image 20240612004327.png]]
원하는 결과가 나왔다.

단위 행렬로 리셋하는 대신에 이전의 행렬을 스택에 저장하는 방법도 사용할 수 있다. 행렬을 스택에 저장하거나 복구할 때는 다음 함수를 호출한다.

void glPushMatrix(void);
void glPopMatrix(void);

행렬은 단순한 하나의 값이 아니라 스택에 여러 개가 저장되며 그 중 스택의 제일 위에 있는 행렬이 현재 행렬이다. 스택의 깊이는 행렬의 종류에 따라 다른데 모델뷰 행렬은 32개까지 저장할 수 있으며 투영 행렬은 2개만 저장할 수 있다. 다음과 같이 해도 결과는 같다.
```
void DoDisplay()
{
    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glutWireTeapot(0.2);

    glPushMatrix();
    glTranslatef(0.6, 0.0, 0.0);
    glutWireTeapot(0.2);
    glPopMatrix();

    glTranslatef(0.0, 0.6, 0.0);
    glutWireTeapot(0.2);
    glPopMatrix();

    glFlush();
}
```
그리기 전의 행렬을 일단 저장한다. 원점에 주전자를 그린 후 오른쪽으로 이동하기 전에 한번 더 저장한다. 이 상태에서 오른쪽으로 이동한 곳에 주전자를 그리고 다시 복구한다. 원점으로 제깍 돌아올 것이다. 이 상태에서 위로 이동한 후 그리면 원점 바로 위가 된다. 모든 그리기가 끝난 후 다시 복구하면 DoDisplay를 호출하기 전의 상태로 돌아간다.

행렬을 리셋하는 방법은 무조건 단위 행렬로 돌아가는데 비해 스택을 사용하는 방법은 이전 상태를 그대로 저장했다가 복구한다는 면에서 더 범용적이다. DoDisplay 안에서 행렬을 어떻게 조작하든간에 리턴할 때 원래대로 복구하므로 외부에서 가한 변환이 유지되며 그리기를 여러 번 하더라도 변환이 누적되지 않는다.

여러 곳에서 공유되는 전역 변수나 상태는 원칙적으로 바꾼 놈이 원래대로 돌려 놓는 것이 옳다. 행렬도 상태 머신에 저장되는 전역 값이므로 행렬을 바꾸는 측에서 원래값을 복원하는 것이 좋다. 이후 변환을 수행하는 코드에서는 원칙대로 행렬을 저장한 후 리턴하기 전에 복구할 것이다. 

다음 함수는 물체를 확대한다.
void glScale[f, d] (GLfloat x, GLfloat y, GLfloat z);

스케일값이 1보다 더 크면 확대되고 더 작으면 축소된다. 일정한 크기로 확대, 축소하고 싶다면 세 방향 모두 같은 비율을 주어야 한다. 각 방향별로 다른 배율을 주면 찌그러진 모양을 만들 수도 있다.

다음 함수는 회전시킨다.
void glRotate[f, d] (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);

angle은 회전시킬 각도이며 반시계 방향의 360분법 각도이다. x, y, z는 회전의 기준이 되는 벡터이다. 다음은 X 축을 기준으로 45도 회전시킨 것이다.

회전 함수들은 항상 원점을 기준으로 물체를 회전시킨다. 물체의 중심이 어디인지는 알지도 못하며 각 물체마다 중심이 다르므로 그렇게 할 수도 없다. 삼각형의 중심을 기준으로 회전시키려면 다음 세 단계를 거쳐야 한다.

glTranslatef(0.5, 0.5, 0.0);
glRotatef(45.0, 0.0, 0.0, 1.0);
glTranslatef(-0.5, -0.5, 0.0);

1. 그림을 원점으로 가져다둔다.
2. 그림을 회전시킨다.
3. 그림을 원래 자리로 돌린다.

이러면 우리가 원하는 물체를 중심으로한 회전을 이룰수 있다.
뭔가 복잡해 보이고 여러 단계를 거쳐 느릴 것 같지만 이 단계들이 모두 행렬식 하나로 합쳐서 실행되므로 실행 속도상의 불이익은 없다.

### 투영

모델뷰 변환은 3차원 공간상에서 물체의 위치나 크기를 조정한다. 이 물체들을 화면에 출력하려면 결국은 2차원의 평면으로 옮겨야 한다. 아직까지 3차원 모니터라는 것은 없으며 인쇄를 해도 평평한 종이에 출력해야 하기 때문이다. 3차원 좌표를 2차원으로 바꾸는 것을 투영(Projection)이라고 한다. 투영은 3차원 좌표를 대응되는 2차원 좌표로 전환한다.

또한 투영은 보이는 범위를 제한하기도 한다. 3차원 공간에 그려진 물체라고 해서 모두 다 보여야 하는 것은 아니며 그 중 필요한 범위를 설정하여 일부만 표시한다. 보이는 영역을 잘라내는 것을 클리핑이라고 하며 클리핑 영역 안쪽의 보이는 범위를 가시 영역(View volume)이라고 한다. 상하좌우의 물체중 시야에 들어오는 것만 포함하며 나머지는 잘라낸다. 또한 관찰자의 뒤쪽에 있는 것도 잘라내며 앞쪽에 있더라도 너무 멀리 있는 것은 제외해야 한다.

개념적으로 투영은 유리창에 비친 모습을 그대로 그려내는 것이다. 어떤 3차원 장면 앞에 유리창을 대고 그 유리창에 보이는 모습을 그대로 그리는 것이 바로 투영이다. 유리창은 평면이고 이 평면의 면적은 제한적이므로 장면의 일부만 담을 수 있다. 카메라가 장면을 촬영하는 것도 일종의 투영인데 3차원 공간을 찍어도 필름은 2차원의 평면이기 때문이다. 사람의 감각기관도 망막은 2차원이므로 3차원을 투영하여 인식하는 것이다. 다만 두 눈의 시야가 겹치는 것을 이용하여 거리를 판별해내는 것이다.

투영과 클리핑은 화면의 크기에 영향을 받는다. 그래서 투영은 보통 화면의 크기가 바뀔 때 현재 화면 크기에 맞게 지정한다. 화면 크기가 바뀌는 시점에 특정한 처리를 하려면 다음 함수로 콜백을 등록한다.

void glutReshapeFunc(void (* func)(int width, int height));

콜백 함수의 인수로 작업영역의 폭과 높이가 전달된다. 윈도우의 크기가 아니라 작업영역 즉, 그림이 그려지는 영역의 크기임을 유의하자. 이 영역의 비율로 종횡비를 계산하고 화면에 들어올만큼만 클리핑해야 한다.

투영은 굉장히 변수가 많은 기법이라 이것 저것 바꿔 가며 결과를 비교해 봐야 이해하기 쉽다. 다음 예제는 투영 기능을 테스트한다. 여러 가지 투영 방식을 동일하게 비교하기 위해 직교 투영의 Near, Far를 디폴트와 달리 -1, 1로 지정했다. 직교 투영의 Near, Far 디폴트는 원래 1, -1이며 음수로 적용하므로 사용자측의 z좌표는 음수이다. 디폴트를 -1, 1로 조정하면 z축은 사용자쪽이 양수가 되므로 피라미드의 꼭대기를 0.8로 부호를 바꾸었다.

투영 방법은 
**직교 투영(Orhographic) : 거리에 상관없이 물체의 크기를 계산,**
**원근 투영(Perspective) :거리에 따라 물체의 크기를 다르게 계산**

두 가지가 있다. 어떤 방법을 사용하는가에 따라 3차원 장면이 2차원 평면에 사상되는 방법이 달라진다. 디폴트는 직교 투영이며 위 예제도 직교 투영을 디폴트로 선택한다. 직교 투영은 거리에 상관없이 물체의 크기를 계산한다. 멀리 있는 물체라도 크기가 같다면 투영된 결과도 동일한 크기를 가진다. 직교 투영은 다음 함수로 지정한다.

void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top,
GLdouble nearVal, GLdouble farVal);

좌우하상근원(LRBTNF) 순서대로 클리핑 영역을 설정한다. 이 영역이 평행하게 투영면에 비춰진다. 물체가 투영면에 평행하게 맺히므로 평행 투영이라고도 한다.

![](http://www.soen.kr/lecture/library/opengl/opengl-8.files/image036.gif)

left, right는 수평으로 3차원 공간의 어느 부분을 자를 것인가를 지정한다. bottom, top은 수직으로 어느 부분을 자를 것인가를 지정한다. near, far는 가시 영역의 전방 끝과 후방 끝을 나타낸다. 시점 좌표계가 오른손 법칙을 따르기 때문에 절단면의 z 좌표는 이 값의 부호를 바꾸어야 한다.  near, far가 -1, 1로 되어 있으면 앞쪽이 1이고 뒤쪽이 -1이 된다.

이 예제는 디폴트와 동일한 클리핑 영역을 사용하되 near와 far의 부호만 바꾸었다. 대신 피라미드의 꼭대기를 양수로 줌으로써 사용자쪽을 바라보도록 했다. 그래서 지금까지의 예제와 마찬가지로 피라미드를 정면에서 바라본 모양으로 그려진다.
![[Pasted image 20240612010231.png]]
직교 투영은 평행하게 투영하므로 공간상의 크기가 같으면 거리에 상관없이 동일한 크기로 보인다. 피라미드를 (30, -120) 각도로 회전하여 밑면이 보이도록 해 보자.
![[Pasted image 20240612010521.png]]
밑면의 앞쪽변과 뒷쪽변, 윗변과 아랫변이 똑같은 길이로 보인다. 실세계에서는 앞쪽과 뒤쪽의 거리가 다르기 때문에 앞쪽변이 더 길게 보이고 뒷쪽변이 짧게 보여야 한다. 책을 비스듬하게 들고 옆에서 바라보면 멀리 있는 쪽과 가까이 있는 쪽의 길이가 다른 것이 정상이다. 하지만 직교 투영은 평행하게 투영하므로 공간상의 크기가 투영면에 그대로 반영되는 특징을 보인다.

반면 원근 투영은 거리에 따라 물체의 크기가 달라진다. 똑같은 크기라도 가까이 있는 물체는 조금 크게 그리고 멀리 있는 물체는 작게 그린다. 실제로 우리가 풍경을 바라보는대로 사실적으로 그려진다. 사실감이 중요한 3D 게임에서는 주로 원근 투영을 사용한다. 원근 투영을 할 때는 다음 함수를 호출한다.

void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal);

인수의 순서는 직교 투영과 동일하되 near, far가 좌표가 아니라 시점에서의 거리를 지정하므로 둘 다 반드시 양수여야 한다. 이 함수는 사각뿔의 윗부분을 잘라낸 절두체(Frustum)로 가시 영역을 설정한다.
![](http://www.soen.kr/lecture/library/opengl/opengl-8.files/image052.gif)

절두체는 직관성이 떨어진다. 그래서 다음 유틸리티 함수로 원근 투영을 설정하기도 한다. 시야각과 화면의 종횡비, near, far를 지정함으로써 절두체를 정의한다. 절두체와는 달리 시선이 정확하게 가시영역의 중심을 통과한다.

void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);

팝업 메뉴에서 Frustum이나 Perspective를 선택하면 원근 투영으로 바뀌며 Near는 1, far는 10으로 정의된다. 원근 투영을 하면 원점에 있는 물체가 너무 가까와 가시 영역에 들어오지 못하므로 z축으로 -2만큼 더 뒤쪽으로 이동시켰다.
![[Pasted image 20240612010648.png]]
직교 투영보다는 원근 투영이 훨씬 더 사실적이고 우리가 실세계를 보는 것과 비슷하다. 그러나 직교 투영이 적합한 경우도 많은데 CAD 설계도면이나 지도, 아파트 평면도 등이 직교 투영으로 그려진 대표적인 예이다.
![[Pasted image 20240612010718.png]]
지도는 하늘에서 바라본 모양을 그린 것인데 실제로 하늘에서 땅쪽을 내려다 보면 저렇게 보이지 않는다. 시점 바로 아래의 도로는 폭이 넓어 보이고 멀리 있는 도로는 좁아 보이다가 결국은 소실점으로 사라지는 것이 정상이다. 하지만 지도는 직교 투영으로 그리는 것이 보통이므로 도로의 폭이 똑같아 보이는 것이다.

### 뷰포트 변환

투영 변환 후에는 뷰포트 변환이 수행된다. 투영 변환은 클리핑 영역으로 장면의 어디를 출력할 것인가를 결정하는 것이고 뷰포트 변환은 클리핑 및 투영된 평면 이미지를 윈도우의 어디쯤에다 출력할 것인지를 지정한다. 뷰포트 변환은 다음 함수로 수행한다.

void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

(x,y)는 뷰포트의 왼쪽 아래 좌표이며 width, height는 폭과 높이이다. OpenGL에서는 윈도우의 좌표계도 좌상단이 아닌 좌하단이 원점이다. 디폴트 뷰포트 변환은 다음과 같다.

glViewport(0,0,width,height);

이 함수는 보통 윈도우의 크기가 변경되는 ReShape 콜백에서 호출한다. 좌하단은 원점이고 폭과 높이는 창의 크기와 일치하므로 디폴트대로 출력하면 윈도우 전체를 가득 채운다. 이 값을 조정하면 창의 일부만 채울 수도 있다.

### 행렬

앞에서 봤다시피 여러 가지 변환을 순차적으로 적용하려면 엄청난 연산 과정이 필요하다. 연산이 복잡하므로 굉장히 오랜 시간이 걸릴 것 같지만 행렬의 수학적 특성을 잘 이용하면 빠른 속도로 연산을 수행할 수 있다. 그래서 OpenGL은 각종 변환에 행렬을 많이 사용한다. 여기서는 행렬 연산이 수행되는 과정을 연구해 보고 왜 빠른지에 대해 알아 보자.

OpenGL이 변환에 사용하는 행렬은 4*4 크기의 행렬이다. 3차원 공간은 3개의 좌표로 구성되지만 연산의 편의를 위해 한차원 더 높은 4*4 행렬을 사용한다. 왜 그런지는 잠시 후에 연구해 보기로 하자. 메모리에서 4*4 행렬을 표현하는 방법은 여러 가지가 있는데 일단 다음 두 가지를 생각할 수 있다.

GLfloat matrix [4]  [4];

GLfloat matrix[16];

4* 4 이차원 배열로 표현할 수도 있고 16개의 요소를 가지는 일차원 배열로 표현할 수도 있다. 이차원 배열이 더 직관적이지만 효율은 일차원 배열이 더 좋다. 2차원 배열이라고 해도 어차피 요소 개수가 고정되어 있으므로 1차원으로 표현할 수 있다. 1차원 배열로 고정 크기의 2차원 배열을 표현하는 방법은 원소를 나열하는 순서에 따라 다음 2가지로 나누어진다.

![](http://www.soen.kr/lecture/library/opengl/opengl-8.files/image084.gif)

OpenGL은 주로 열 기준 행렬을 사용하는데 열 기준 행렬이 몇 가지 이점이 있기 때문이다. 다음 함수는 배열로부터 열 기준 행열을 읽어들인다. 배열 m은 16개의 요소를 열 기준으로 가지고 있어야 한다.

void glLoadMatrix[f,d] (const GLfloat * m);

수학에서는 흔히 행 기준 행렬을 많이 사용한다. **OpenGL은 주로 열 기준 행렬을 사용하지만 원한다면 행 기준 행렬도 사용할 수는 있다.** 행 기준 행렬로 읽어들일 때는 다음 함수를 사용한다.

void glLoadTransposeMatrix[f, d] (const GLfloat * m);

이 함수의 이름에 포함된 Transpose는 전치라는 뜻인데 열 기준 행렬의 전치 행렬이 행 기준 행렬이기 때문이다. 전치라는 것은 대각선을 기준으로 원소를 맞바꾸는 연산이다. 행렬끼리 곱할 때는 다음 함수를 호출한다.

void glMultMatrixf(const GLfloat * m);
void glMultTransposeMatrixf(const GLfloat * m);
